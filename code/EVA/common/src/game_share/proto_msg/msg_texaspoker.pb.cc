// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_texaspoker.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "msg_texaspoker.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MsgTexasPokerPlayerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgTexasPokerPlayerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgTexasPokerRoomInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgTexasPokerRoomInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRoleAction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRoleAction_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgCallPour_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgCallPour_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRaisePour_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRaisePour_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRewardData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRewardData_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRewardList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRewardList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgResetCoins_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgResetCoins_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgApplyGame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgApplyGame_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgCancelApply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgCancelApply_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgRequestQuit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgRequestQuit_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TPokerModle_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TPokerRoleState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TTexasPokerState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_msg_5ftexaspoker_2eproto() {
  protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "msg_texaspoker.proto");
  GOOGLE_CHECK(file != NULL);
  MsgTexasPokerPlayerInfo_descriptor_ = file->message_type(0);
  static const int MsgTexasPokerPlayerInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, player_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, pour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, coins_),
  };
  MsgTexasPokerPlayerInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgTexasPokerPlayerInfo_descriptor_,
      MsgTexasPokerPlayerInfo::default_instance_,
      MsgTexasPokerPlayerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerPlayerInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgTexasPokerPlayerInfo));
  MsgTexasPokerRoomInfo_descriptor_ = file->message_type(1);
  static const int MsgTexasPokerRoomInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, room_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, player_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, center_card_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, self_card_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, run_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, total_pour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, seats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, largecoins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, maker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, roomid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, room_info_),
  };
  MsgTexasPokerRoomInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgTexasPokerRoomInfo_descriptor_,
      MsgTexasPokerRoomInfo::default_instance_,
      MsgTexasPokerRoomInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgTexasPokerRoomInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgTexasPokerRoomInfo));
  MsgRoleAction_descriptor_ = file->message_type(2);
  static const int MsgRoleAction_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRoleAction, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRoleAction, state_),
  };
  MsgRoleAction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRoleAction_descriptor_,
      MsgRoleAction::default_instance_,
      MsgRoleAction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRoleAction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRoleAction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRoleAction));
  MsgCallPour_descriptor_ = file->message_type(3);
  static const int MsgCallPour_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCallPour, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCallPour, pour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCallPour, coins_),
  };
  MsgCallPour_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgCallPour_descriptor_,
      MsgCallPour::default_instance_,
      MsgCallPour_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCallPour, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCallPour, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgCallPour));
  MsgRaisePour_descriptor_ = file->message_type(4);
  static const int MsgRaisePour_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRaisePour, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRaisePour, pour_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRaisePour, coins_),
  };
  MsgRaisePour_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRaisePour_descriptor_,
      MsgRaisePour::default_instance_,
      MsgRaisePour_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRaisePour, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRaisePour, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRaisePour));
  MsgRewardData_descriptor_ = file->message_type(5);
  static const int MsgRewardData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, reward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, coins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, rankin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, hand_card_),
  };
  MsgRewardData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRewardData_descriptor_,
      MsgRewardData::default_instance_,
      MsgRewardData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRewardData));
  MsgRewardList_descriptor_ = file->message_type(6);
  static const int MsgRewardList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardList, reward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardList, goback_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardList, isshow_),
  };
  MsgRewardList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRewardList_descriptor_,
      MsgRewardList::default_instance_,
      MsgRewardList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRewardList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRewardList));
  MsgResetCoins_descriptor_ = file->message_type(7);
  static const int MsgResetCoins_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgResetCoins, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgResetCoins, coins_),
  };
  MsgResetCoins_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgResetCoins_descriptor_,
      MsgResetCoins::default_instance_,
      MsgResetCoins_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgResetCoins, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgResetCoins, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgResetCoins));
  MsgApplyGame_descriptor_ = file->message_type(8);
  static const int MsgApplyGame_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgApplyGame, room_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgApplyGame, timeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgApplyGame, money_),
  };
  MsgApplyGame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgApplyGame_descriptor_,
      MsgApplyGame::default_instance_,
      MsgApplyGame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgApplyGame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgApplyGame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgApplyGame));
  MsgCancelApply_descriptor_ = file->message_type(9);
  static const int MsgCancelApply_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCancelApply, room_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCancelApply, timeid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCancelApply, money_),
  };
  MsgCancelApply_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgCancelApply_descriptor_,
      MsgCancelApply::default_instance_,
      MsgCancelApply_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCancelApply, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgCancelApply, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgCancelApply));
  MsgRequestQuit_descriptor_ = file->message_type(10);
  static const int MsgRequestQuit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRequestQuit, ranking_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRequestQuit, reward_),
  };
  MsgRequestQuit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgRequestQuit_descriptor_,
      MsgRequestQuit::default_instance_,
      MsgRequestQuit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRequestQuit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgRequestQuit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgRequestQuit));
  TPokerModle_descriptor_ = file->enum_type(0);
  TPokerRoleState_descriptor_ = file->enum_type(1);
  TTexasPokerState_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_msg_5ftexaspoker_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgTexasPokerPlayerInfo_descriptor_, &MsgTexasPokerPlayerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgTexasPokerRoomInfo_descriptor_, &MsgTexasPokerRoomInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRoleAction_descriptor_, &MsgRoleAction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgCallPour_descriptor_, &MsgCallPour::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRaisePour_descriptor_, &MsgRaisePour::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRewardData_descriptor_, &MsgRewardData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRewardList_descriptor_, &MsgRewardList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgResetCoins_descriptor_, &MsgResetCoins::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgApplyGame_descriptor_, &MsgApplyGame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgCancelApply_descriptor_, &MsgCancelApply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgRequestQuit_descriptor_, &MsgRequestQuit::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_msg_5ftexaspoker_2eproto() {
  delete MsgTexasPokerPlayerInfo::default_instance_;
  delete MsgTexasPokerPlayerInfo_reflection_;
  delete MsgTexasPokerRoomInfo::default_instance_;
  delete MsgTexasPokerRoomInfo_reflection_;
  delete MsgRoleAction::default_instance_;
  delete MsgRoleAction_reflection_;
  delete MsgCallPour::default_instance_;
  delete MsgCallPour_reflection_;
  delete MsgRaisePour::default_instance_;
  delete MsgRaisePour_reflection_;
  delete MsgRewardData::default_instance_;
  delete MsgRewardData_reflection_;
  delete MsgRewardList::default_instance_;
  delete MsgRewardList_reflection_;
  delete MsgResetCoins::default_instance_;
  delete MsgResetCoins_reflection_;
  delete MsgApplyGame::default_instance_;
  delete MsgApplyGame_reflection_;
  delete MsgCancelApply::default_instance_;
  delete MsgCancelApply_reflection_;
  delete MsgRequestQuit::default_instance_;
  delete MsgRequestQuit_reflection_;
}

void protobuf_AddDesc_msg_5ftexaspoker_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_public_5fpro_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024msg_texaspoker.proto\032\020public_pro.proto"
    "\"j\n\027MsgTexasPokerPlayerInfo\022#\n\013player_in"
    "fo\030\001 \001(\0132\016.MsgPlayerInfo\022\r\n\005state\030\002 \001(\r\022"
    "\014\n\004pour\030\003 \001(\004\022\r\n\005coins\030\004 \001(\004\"\262\002\n\025MsgTexa"
    "sPokerRoomInfo\022%\n\nroom_state\030\001 \001(\0162\021.TTe"
    "xasPokerState\022-\n\013player_list\030\002 \003(\0132\030.Msg"
    "TexasPokerPlayerInfo\022\023\n\013center_card\030\003 \003("
    "\r\022\021\n\tself_card\030\004 \003(\r\022\020\n\010run_time\030\005 \001(\004\022\022"
    "\n\ntotal_pour\030\006 \001(\004\022\r\n\005seats\030\007 \003(\004\022\016\n\006act"
    "ion\030\010 \001(\004\022\022\n\nlargeCoins\030\t \001(\004\022\r\n\005maker\030\n"
    " \001(\r\022\016\n\006roomID\030\013 \001(\004\022#\n\troom_info\030\014 \001(\0132"
    "\020.MsgBaseRoomInfo\"A\n\rMsgRoleAction\022\016\n\006ro"
    "leID\030\001 \001(\004\022 \n\005state\030\002 \001(\0162\021.TTexasPokerS"
    "tate\":\n\013MsgCallPour\022\016\n\006roleid\030\001 \001(\004\022\014\n\004p"
    "our\030\002 \001(\004\022\r\n\005coins\030\003 \001(\004\";\n\014MsgRaisePour"
    "\022\016\n\006roleid\030\001 \001(\004\022\014\n\004pour\030\002 \001(\004\022\r\n\005coins\030"
    "\003 \001(\004\"p\n\rMsgRewardData\022\016\n\006roleid\030\001 \001(\004\022\016"
    "\n\006reward\030\002 \001(\004\022\r\n\005coins\030\003 \001(\004\022\r\n\005money\030\004"
    " \001(\004\022\016\n\006rankin\030\005 \001(\r\022\021\n\thand_card\030\006 \003(\r\""
    "_\n\rMsgRewardList\022\036\n\006reward\030\001 \003(\0132\016.MsgRe"
    "wardData\022\036\n\006goback\030\002 \003(\0132\016.MsgRewardData"
    "\022\016\n\006isShow\030\003 \001(\010\".\n\rMsgResetCoins\022\016\n\006rol"
    "eid\030\001 \001(\004\022\r\n\005coins\030\002 \001(\004\"@\n\014MsgApplyGame"
    "\022\021\n\troom_type\030\001 \001(\t\022\016\n\006timeid\030\002 \001(\r\022\r\n\005m"
    "oney\030\003 \001(\004\"B\n\016MsgCancelApply\022\021\n\troom_typ"
    "e\030\001 \001(\t\022\016\n\006timeid\030\002 \001(\r\022\r\n\005money\030\003 \001(\004\"1"
    "\n\016MsgRequestQuit\022\017\n\007ranking\030\001 \001(\r\022\016\n\006rew"
    "ard\030\002 \001(\010*\362\001\n\013TPokerModle\022\016\n\nPOKER_NULL\020"
    "\000\022\023\n\017POKER_HIGT_CARD\020\001\022\022\n\016POKER_ONE_PAIR"
    "\020\002\022\023\n\017POKER_TWO_PAIRS\020\003\022\024\n\020POKER_THREE_K"
    "IND\020\004\022\022\n\016POKER_STRAIGHT\020\005\022\017\n\013POKER_FLUSH"
    "\020\006\022\024\n\020POKER_FULL_HOUSE\020\007\022\023\n\017POKER_FOUR_K"
    "IND\020\010\022\030\n\024POKER_STRAIGHT_FLUSH\020\t\022\025\n\021POKER"
    "_ROYAL_FLUSH\020\n*\244\001\n\017TPokerRoleState\022\017\n\013RO"
    "LE_NORMAL\020\001\022\017\n\013ROLE_MAKERS\020\002\022\022\n\016ROLE_LES"
    "S_POUR\020\004\022\021\n\rROLE_BIG_POUR\020\010\022\020\n\014ROLE_ABAN"
    "DON\020\020\022\021\n\rROLE_BASEPOUR\020 \022\020\n\014ROLE_INVALID"
    "\020@\022\021\n\014ROLE_NEWROLE\020\200\001*\261\004\n\020TTexasPokerSta"
    "te\022\034\n\030TexasPokerStateStartGame\020\000\022\037\n\033Texa"
    "sPokerStateStartPerflop\020\001\022\034\n\030TexasPokerS"
    "tateOneAction\020\002\022\035\n\031TexasPokerStateEndPer"
    "flop\020\003\022\034\n\030TexasPokerStateStartflop\020\004\022\034\n\030"
    "TexasPokerStateTwoAction\020\005\022\032\n\026TexasPoker"
    "StateEndFlop\020\006\022\034\n\030TexasPokerStateStartTu"
    "rn\020\007\022\036\n\032TexasPokerStateThreeAction\020\010\022\032\n\026"
    "TexasPokerStateEndTurn\020\t\022\035\n\031TexasPokerSt"
    "ateStartRiver\020\n\022\035\n\031TexasPokerStateFourAc"
    "tion\020\013\022\033\n\027TexasPokerStateEndRiver\020\014\022\"\n\036T"
    "exasPokerStateShowdownInterim\020\r\022\033\n\027Texas"
    "PokerStateShowdown\020\016\022\034\n\030TeXasPokerStateC"
    "leanJunk\020\017\022\034\n\030TexasPokerStateCloseRoom\020\020"
    "\022\027\n\023TexasPokerStateOver\020\021", 2065);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "msg_texaspoker.proto", &protobuf_RegisterTypes);
  MsgTexasPokerPlayerInfo::default_instance_ = new MsgTexasPokerPlayerInfo();
  MsgTexasPokerRoomInfo::default_instance_ = new MsgTexasPokerRoomInfo();
  MsgRoleAction::default_instance_ = new MsgRoleAction();
  MsgCallPour::default_instance_ = new MsgCallPour();
  MsgRaisePour::default_instance_ = new MsgRaisePour();
  MsgRewardData::default_instance_ = new MsgRewardData();
  MsgRewardList::default_instance_ = new MsgRewardList();
  MsgResetCoins::default_instance_ = new MsgResetCoins();
  MsgApplyGame::default_instance_ = new MsgApplyGame();
  MsgCancelApply::default_instance_ = new MsgCancelApply();
  MsgRequestQuit::default_instance_ = new MsgRequestQuit();
  MsgTexasPokerPlayerInfo::default_instance_->InitAsDefaultInstance();
  MsgTexasPokerRoomInfo::default_instance_->InitAsDefaultInstance();
  MsgRoleAction::default_instance_->InitAsDefaultInstance();
  MsgCallPour::default_instance_->InitAsDefaultInstance();
  MsgRaisePour::default_instance_->InitAsDefaultInstance();
  MsgRewardData::default_instance_->InitAsDefaultInstance();
  MsgRewardList::default_instance_->InitAsDefaultInstance();
  MsgResetCoins::default_instance_->InitAsDefaultInstance();
  MsgApplyGame::default_instance_->InitAsDefaultInstance();
  MsgCancelApply::default_instance_->InitAsDefaultInstance();
  MsgRequestQuit::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_msg_5ftexaspoker_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_msg_5ftexaspoker_2eproto {
  StaticDescriptorInitializer_msg_5ftexaspoker_2eproto() {
    protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  }
} static_descriptor_initializer_msg_5ftexaspoker_2eproto_;
const ::google::protobuf::EnumDescriptor* TPokerModle_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TPokerModle_descriptor_;
}
bool TPokerModle_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TPokerRoleState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TPokerRoleState_descriptor_;
}
bool TPokerRoleState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TTexasPokerState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TTexasPokerState_descriptor_;
}
bool TTexasPokerState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MsgTexasPokerPlayerInfo::kPlayerInfoFieldNumber;
const int MsgTexasPokerPlayerInfo::kStateFieldNumber;
const int MsgTexasPokerPlayerInfo::kPourFieldNumber;
const int MsgTexasPokerPlayerInfo::kCoinsFieldNumber;
#endif  // !_MSC_VER

MsgTexasPokerPlayerInfo::MsgTexasPokerPlayerInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgTexasPokerPlayerInfo)
}

void MsgTexasPokerPlayerInfo::InitAsDefaultInstance() {
  player_info_ = const_cast< ::MsgPlayerInfo*>(&::MsgPlayerInfo::default_instance());
}

MsgTexasPokerPlayerInfo::MsgTexasPokerPlayerInfo(const MsgTexasPokerPlayerInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgTexasPokerPlayerInfo)
}

void MsgTexasPokerPlayerInfo::SharedCtor() {
  _cached_size_ = 0;
  player_info_ = NULL;
  state_ = 0u;
  pour_ = GOOGLE_ULONGLONG(0);
  coins_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgTexasPokerPlayerInfo::~MsgTexasPokerPlayerInfo() {
  // @@protoc_insertion_point(destructor:MsgTexasPokerPlayerInfo)
  SharedDtor();
}

void MsgTexasPokerPlayerInfo::SharedDtor() {
  if (this != default_instance_) {
    delete player_info_;
  }
}

void MsgTexasPokerPlayerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgTexasPokerPlayerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgTexasPokerPlayerInfo_descriptor_;
}

const MsgTexasPokerPlayerInfo& MsgTexasPokerPlayerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgTexasPokerPlayerInfo* MsgTexasPokerPlayerInfo::default_instance_ = NULL;

MsgTexasPokerPlayerInfo* MsgTexasPokerPlayerInfo::New() const {
  return new MsgTexasPokerPlayerInfo;
}

void MsgTexasPokerPlayerInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgTexasPokerPlayerInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(pour_, state_);
    if (has_player_info()) {
      if (player_info_ != NULL) player_info_->::MsgPlayerInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgTexasPokerPlayerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgTexasPokerPlayerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MsgPlayerInfo player_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // optional uint32 state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_pour;
        break;
      }

      // optional uint64 pour = 3;
      case 3: {
        if (tag == 24) {
         parse_pour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pour_)));
          set_has_pour();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_coins;
        break;
      }

      // optional uint64 coins = 4;
      case 4: {
        if (tag == 32) {
         parse_coins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &coins_)));
          set_has_coins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgTexasPokerPlayerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgTexasPokerPlayerInfo)
  return false;
#undef DO_
}

void MsgTexasPokerPlayerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgTexasPokerPlayerInfo)
  // optional .MsgPlayerInfo player_info = 1;
  if (has_player_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->player_info(), output);
  }

  // optional uint32 state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state(), output);
  }

  // optional uint64 pour = 3;
  if (has_pour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->pour(), output);
  }

  // optional uint64 coins = 4;
  if (has_coins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->coins(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgTexasPokerPlayerInfo)
}

::google::protobuf::uint8* MsgTexasPokerPlayerInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgTexasPokerPlayerInfo)
  // optional .MsgPlayerInfo player_info = 1;
  if (has_player_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->player_info(), target);
  }

  // optional uint32 state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->state(), target);
  }

  // optional uint64 pour = 3;
  if (has_pour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->pour(), target);
  }

  // optional uint64 coins = 4;
  if (has_coins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->coins(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgTexasPokerPlayerInfo)
  return target;
}

int MsgTexasPokerPlayerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MsgPlayerInfo player_info = 1;
    if (has_player_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player_info());
    }

    // optional uint32 state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

    // optional uint64 pour = 3;
    if (has_pour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pour());
    }

    // optional uint64 coins = 4;
    if (has_coins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->coins());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgTexasPokerPlayerInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgTexasPokerPlayerInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgTexasPokerPlayerInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgTexasPokerPlayerInfo::MergeFrom(const MsgTexasPokerPlayerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_info()) {
      mutable_player_info()->::MsgPlayerInfo::MergeFrom(from.player_info());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_pour()) {
      set_pour(from.pour());
    }
    if (from.has_coins()) {
      set_coins(from.coins());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgTexasPokerPlayerInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgTexasPokerPlayerInfo::CopyFrom(const MsgTexasPokerPlayerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgTexasPokerPlayerInfo::IsInitialized() const {

  return true;
}

void MsgTexasPokerPlayerInfo::Swap(MsgTexasPokerPlayerInfo* other) {
  if (other != this) {
    std::swap(player_info_, other->player_info_);
    std::swap(state_, other->state_);
    std::swap(pour_, other->pour_);
    std::swap(coins_, other->coins_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgTexasPokerPlayerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgTexasPokerPlayerInfo_descriptor_;
  metadata.reflection = MsgTexasPokerPlayerInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgTexasPokerRoomInfo::kRoomStateFieldNumber;
const int MsgTexasPokerRoomInfo::kPlayerListFieldNumber;
const int MsgTexasPokerRoomInfo::kCenterCardFieldNumber;
const int MsgTexasPokerRoomInfo::kSelfCardFieldNumber;
const int MsgTexasPokerRoomInfo::kRunTimeFieldNumber;
const int MsgTexasPokerRoomInfo::kTotalPourFieldNumber;
const int MsgTexasPokerRoomInfo::kSeatsFieldNumber;
const int MsgTexasPokerRoomInfo::kActionFieldNumber;
const int MsgTexasPokerRoomInfo::kLargeCoinsFieldNumber;
const int MsgTexasPokerRoomInfo::kMakerFieldNumber;
const int MsgTexasPokerRoomInfo::kRoomIDFieldNumber;
const int MsgTexasPokerRoomInfo::kRoomInfoFieldNumber;
#endif  // !_MSC_VER

MsgTexasPokerRoomInfo::MsgTexasPokerRoomInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgTexasPokerRoomInfo)
}

void MsgTexasPokerRoomInfo::InitAsDefaultInstance() {
  room_info_ = const_cast< ::MsgBaseRoomInfo*>(&::MsgBaseRoomInfo::default_instance());
}

MsgTexasPokerRoomInfo::MsgTexasPokerRoomInfo(const MsgTexasPokerRoomInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgTexasPokerRoomInfo)
}

void MsgTexasPokerRoomInfo::SharedCtor() {
  _cached_size_ = 0;
  room_state_ = 0;
  run_time_ = GOOGLE_ULONGLONG(0);
  total_pour_ = GOOGLE_ULONGLONG(0);
  action_ = GOOGLE_ULONGLONG(0);
  largecoins_ = GOOGLE_ULONGLONG(0);
  maker_ = 0u;
  roomid_ = GOOGLE_ULONGLONG(0);
  room_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgTexasPokerRoomInfo::~MsgTexasPokerRoomInfo() {
  // @@protoc_insertion_point(destructor:MsgTexasPokerRoomInfo)
  SharedDtor();
}

void MsgTexasPokerRoomInfo::SharedDtor() {
  if (this != default_instance_) {
    delete room_info_;
  }
}

void MsgTexasPokerRoomInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgTexasPokerRoomInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgTexasPokerRoomInfo_descriptor_;
}

const MsgTexasPokerRoomInfo& MsgTexasPokerRoomInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgTexasPokerRoomInfo* MsgTexasPokerRoomInfo::default_instance_ = NULL;

MsgTexasPokerRoomInfo* MsgTexasPokerRoomInfo::New() const {
  return new MsgTexasPokerRoomInfo;
}

void MsgTexasPokerRoomInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgTexasPokerRoomInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 177) {
    ZR_(run_time_, room_state_);
    total_pour_ = GOOGLE_ULONGLONG(0);
    action_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & 3840) {
    ZR_(largecoins_, roomid_);
    maker_ = 0u;
    if (has_room_info()) {
      if (room_info_ != NULL) room_info_->::MsgBaseRoomInfo::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  player_list_.Clear();
  center_card_.Clear();
  self_card_.Clear();
  seats_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgTexasPokerRoomInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgTexasPokerRoomInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TTexasPokerState room_state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TTexasPokerState_IsValid(value)) {
            set_room_state(static_cast< ::TTexasPokerState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_player_list;
        break;
      }

      // repeated .MsgTexasPokerPlayerInfo player_list = 2;
      case 2: {
        if (tag == 18) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_player_list;
        if (input->ExpectTag(24)) goto parse_center_card;
        break;
      }

      // repeated uint32 center_card = 3;
      case 3: {
        if (tag == 24) {
         parse_center_card:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_center_card())));
        } else if (tag == 26) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_center_card())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_center_card;
        if (input->ExpectTag(32)) goto parse_self_card;
        break;
      }

      // repeated uint32 self_card = 4;
      case 4: {
        if (tag == 32) {
         parse_self_card:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_self_card())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_self_card())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_self_card;
        if (input->ExpectTag(40)) goto parse_run_time;
        break;
      }

      // optional uint64 run_time = 5;
      case 5: {
        if (tag == 40) {
         parse_run_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &run_time_)));
          set_has_run_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_total_pour;
        break;
      }

      // optional uint64 total_pour = 6;
      case 6: {
        if (tag == 48) {
         parse_total_pour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &total_pour_)));
          set_has_total_pour();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_seats;
        break;
      }

      // repeated uint64 seats = 7;
      case 7: {
        if (tag == 56) {
         parse_seats:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 56, input, this->mutable_seats())));
        } else if (tag == 58) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_seats())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_seats;
        if (input->ExpectTag(64)) goto parse_action;
        break;
      }

      // optional uint64 action = 8;
      case 8: {
        if (tag == 64) {
         parse_action:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_largeCoins;
        break;
      }

      // optional uint64 largeCoins = 9;
      case 9: {
        if (tag == 72) {
         parse_largeCoins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &largecoins_)));
          set_has_largecoins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_maker;
        break;
      }

      // optional uint32 maker = 10;
      case 10: {
        if (tag == 80) {
         parse_maker:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &maker_)));
          set_has_maker();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_roomID;
        break;
      }

      // optional uint64 roomID = 11;
      case 11: {
        if (tag == 88) {
         parse_roomID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roomid_)));
          set_has_roomid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_room_info;
        break;
      }

      // optional .MsgBaseRoomInfo room_info = 12;
      case 12: {
        if (tag == 98) {
         parse_room_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_room_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgTexasPokerRoomInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgTexasPokerRoomInfo)
  return false;
#undef DO_
}

void MsgTexasPokerRoomInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgTexasPokerRoomInfo)
  // optional .TTexasPokerState room_state = 1;
  if (has_room_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->room_state(), output);
  }

  // repeated .MsgTexasPokerPlayerInfo player_list = 2;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->player_list(i), output);
  }

  // repeated uint32 center_card = 3;
  for (int i = 0; i < this->center_card_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->center_card(i), output);
  }

  // repeated uint32 self_card = 4;
  for (int i = 0; i < this->self_card_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->self_card(i), output);
  }

  // optional uint64 run_time = 5;
  if (has_run_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->run_time(), output);
  }

  // optional uint64 total_pour = 6;
  if (has_total_pour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->total_pour(), output);
  }

  // repeated uint64 seats = 7;
  for (int i = 0; i < this->seats_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      7, this->seats(i), output);
  }

  // optional uint64 action = 8;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->action(), output);
  }

  // optional uint64 largeCoins = 9;
  if (has_largecoins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->largecoins(), output);
  }

  // optional uint32 maker = 10;
  if (has_maker()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->maker(), output);
  }

  // optional uint64 roomID = 11;
  if (has_roomid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->roomid(), output);
  }

  // optional .MsgBaseRoomInfo room_info = 12;
  if (has_room_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->room_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgTexasPokerRoomInfo)
}

::google::protobuf::uint8* MsgTexasPokerRoomInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgTexasPokerRoomInfo)
  // optional .TTexasPokerState room_state = 1;
  if (has_room_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->room_state(), target);
  }

  // repeated .MsgTexasPokerPlayerInfo player_list = 2;
  for (int i = 0; i < this->player_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->player_list(i), target);
  }

  // repeated uint32 center_card = 3;
  for (int i = 0; i < this->center_card_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(3, this->center_card(i), target);
  }

  // repeated uint32 self_card = 4;
  for (int i = 0; i < this->self_card_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->self_card(i), target);
  }

  // optional uint64 run_time = 5;
  if (has_run_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->run_time(), target);
  }

  // optional uint64 total_pour = 6;
  if (has_total_pour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->total_pour(), target);
  }

  // repeated uint64 seats = 7;
  for (int i = 0; i < this->seats_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt64ToArray(7, this->seats(i), target);
  }

  // optional uint64 action = 8;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->action(), target);
  }

  // optional uint64 largeCoins = 9;
  if (has_largecoins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->largecoins(), target);
  }

  // optional uint32 maker = 10;
  if (has_maker()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->maker(), target);
  }

  // optional uint64 roomID = 11;
  if (has_roomid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->roomid(), target);
  }

  // optional .MsgBaseRoomInfo room_info = 12;
  if (has_room_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->room_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgTexasPokerRoomInfo)
  return target;
}

int MsgTexasPokerRoomInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TTexasPokerState room_state = 1;
    if (has_room_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->room_state());
    }

    // optional uint64 run_time = 5;
    if (has_run_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->run_time());
    }

    // optional uint64 total_pour = 6;
    if (has_total_pour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->total_pour());
    }

    // optional uint64 action = 8;
    if (has_action()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->action());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 largeCoins = 9;
    if (has_largecoins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->largecoins());
    }

    // optional uint32 maker = 10;
    if (has_maker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->maker());
    }

    // optional uint64 roomID = 11;
    if (has_roomid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roomid());
    }

    // optional .MsgBaseRoomInfo room_info = 12;
    if (has_room_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->room_info());
    }

  }
  // repeated .MsgTexasPokerPlayerInfo player_list = 2;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  // repeated uint32 center_card = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->center_card_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->center_card(i));
    }
    total_size += 1 * this->center_card_size() + data_size;
  }

  // repeated uint32 self_card = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->self_card_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->self_card(i));
    }
    total_size += 1 * this->self_card_size() + data_size;
  }

  // repeated uint64 seats = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->seats_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->seats(i));
    }
    total_size += 1 * this->seats_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgTexasPokerRoomInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgTexasPokerRoomInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgTexasPokerRoomInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgTexasPokerRoomInfo::MergeFrom(const MsgTexasPokerRoomInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
  center_card_.MergeFrom(from.center_card_);
  self_card_.MergeFrom(from.self_card_);
  seats_.MergeFrom(from.seats_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_state()) {
      set_room_state(from.room_state());
    }
    if (from.has_run_time()) {
      set_run_time(from.run_time());
    }
    if (from.has_total_pour()) {
      set_total_pour(from.total_pour());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_largecoins()) {
      set_largecoins(from.largecoins());
    }
    if (from.has_maker()) {
      set_maker(from.maker());
    }
    if (from.has_roomid()) {
      set_roomid(from.roomid());
    }
    if (from.has_room_info()) {
      mutable_room_info()->::MsgBaseRoomInfo::MergeFrom(from.room_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgTexasPokerRoomInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgTexasPokerRoomInfo::CopyFrom(const MsgTexasPokerRoomInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgTexasPokerRoomInfo::IsInitialized() const {

  return true;
}

void MsgTexasPokerRoomInfo::Swap(MsgTexasPokerRoomInfo* other) {
  if (other != this) {
    std::swap(room_state_, other->room_state_);
    player_list_.Swap(&other->player_list_);
    center_card_.Swap(&other->center_card_);
    self_card_.Swap(&other->self_card_);
    std::swap(run_time_, other->run_time_);
    std::swap(total_pour_, other->total_pour_);
    seats_.Swap(&other->seats_);
    std::swap(action_, other->action_);
    std::swap(largecoins_, other->largecoins_);
    std::swap(maker_, other->maker_);
    std::swap(roomid_, other->roomid_);
    std::swap(room_info_, other->room_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgTexasPokerRoomInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgTexasPokerRoomInfo_descriptor_;
  metadata.reflection = MsgTexasPokerRoomInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRoleAction::kRoleIDFieldNumber;
const int MsgRoleAction::kStateFieldNumber;
#endif  // !_MSC_VER

MsgRoleAction::MsgRoleAction()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgRoleAction)
}

void MsgRoleAction::InitAsDefaultInstance() {
}

MsgRoleAction::MsgRoleAction(const MsgRoleAction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgRoleAction)
}

void MsgRoleAction::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRoleAction::~MsgRoleAction() {
  // @@protoc_insertion_point(destructor:MsgRoleAction)
  SharedDtor();
}

void MsgRoleAction::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRoleAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRoleAction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRoleAction_descriptor_;
}

const MsgRoleAction& MsgRoleAction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgRoleAction* MsgRoleAction::default_instance_ = NULL;

MsgRoleAction* MsgRoleAction::New() const {
  return new MsgRoleAction;
}

void MsgRoleAction::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRoleAction*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roleid_, state_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRoleAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgRoleAction)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleID = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // optional .TTexasPokerState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TTexasPokerState_IsValid(value)) {
            set_state(static_cast< ::TTexasPokerState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgRoleAction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgRoleAction)
  return false;
#undef DO_
}

void MsgRoleAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgRoleAction)
  // optional uint64 roleID = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional .TTexasPokerState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgRoleAction)
}

::google::protobuf::uint8* MsgRoleAction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgRoleAction)
  // optional uint64 roleID = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional .TTexasPokerState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgRoleAction)
  return target;
}

int MsgRoleAction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleID = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional .TTexasPokerState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRoleAction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRoleAction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRoleAction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRoleAction::MergeFrom(const MsgRoleAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRoleAction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRoleAction::CopyFrom(const MsgRoleAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRoleAction::IsInitialized() const {

  return true;
}

void MsgRoleAction::Swap(MsgRoleAction* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRoleAction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRoleAction_descriptor_;
  metadata.reflection = MsgRoleAction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgCallPour::kRoleidFieldNumber;
const int MsgCallPour::kPourFieldNumber;
const int MsgCallPour::kCoinsFieldNumber;
#endif  // !_MSC_VER

MsgCallPour::MsgCallPour()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgCallPour)
}

void MsgCallPour::InitAsDefaultInstance() {
}

MsgCallPour::MsgCallPour(const MsgCallPour& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgCallPour)
}

void MsgCallPour::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  pour_ = GOOGLE_ULONGLONG(0);
  coins_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgCallPour::~MsgCallPour() {
  // @@protoc_insertion_point(destructor:MsgCallPour)
  SharedDtor();
}

void MsgCallPour::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgCallPour::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgCallPour::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgCallPour_descriptor_;
}

const MsgCallPour& MsgCallPour::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgCallPour* MsgCallPour::default_instance_ = NULL;

MsgCallPour* MsgCallPour::New() const {
  return new MsgCallPour;
}

void MsgCallPour::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgCallPour*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roleid_, coins_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgCallPour::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgCallPour)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pour;
        break;
      }

      // optional uint64 pour = 2;
      case 2: {
        if (tag == 16) {
         parse_pour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pour_)));
          set_has_pour();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_coins;
        break;
      }

      // optional uint64 coins = 3;
      case 3: {
        if (tag == 24) {
         parse_coins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &coins_)));
          set_has_coins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgCallPour)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgCallPour)
  return false;
#undef DO_
}

void MsgCallPour::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgCallPour)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional uint64 pour = 2;
  if (has_pour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->pour(), output);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->coins(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgCallPour)
}

::google::protobuf::uint8* MsgCallPour::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgCallPour)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional uint64 pour = 2;
  if (has_pour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->pour(), target);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->coins(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgCallPour)
  return target;
}

int MsgCallPour::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional uint64 pour = 2;
    if (has_pour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pour());
    }

    // optional uint64 coins = 3;
    if (has_coins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->coins());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgCallPour::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgCallPour* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgCallPour*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgCallPour::MergeFrom(const MsgCallPour& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_pour()) {
      set_pour(from.pour());
    }
    if (from.has_coins()) {
      set_coins(from.coins());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgCallPour::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgCallPour::CopyFrom(const MsgCallPour& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgCallPour::IsInitialized() const {

  return true;
}

void MsgCallPour::Swap(MsgCallPour* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(pour_, other->pour_);
    std::swap(coins_, other->coins_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgCallPour::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgCallPour_descriptor_;
  metadata.reflection = MsgCallPour_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRaisePour::kRoleidFieldNumber;
const int MsgRaisePour::kPourFieldNumber;
const int MsgRaisePour::kCoinsFieldNumber;
#endif  // !_MSC_VER

MsgRaisePour::MsgRaisePour()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgRaisePour)
}

void MsgRaisePour::InitAsDefaultInstance() {
}

MsgRaisePour::MsgRaisePour(const MsgRaisePour& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgRaisePour)
}

void MsgRaisePour::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  pour_ = GOOGLE_ULONGLONG(0);
  coins_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRaisePour::~MsgRaisePour() {
  // @@protoc_insertion_point(destructor:MsgRaisePour)
  SharedDtor();
}

void MsgRaisePour::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRaisePour::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRaisePour::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRaisePour_descriptor_;
}

const MsgRaisePour& MsgRaisePour::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgRaisePour* MsgRaisePour::default_instance_ = NULL;

MsgRaisePour* MsgRaisePour::New() const {
  return new MsgRaisePour;
}

void MsgRaisePour::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRaisePour*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roleid_, coins_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRaisePour::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgRaisePour)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pour;
        break;
      }

      // optional uint64 pour = 2;
      case 2: {
        if (tag == 16) {
         parse_pour:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &pour_)));
          set_has_pour();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_coins;
        break;
      }

      // optional uint64 coins = 3;
      case 3: {
        if (tag == 24) {
         parse_coins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &coins_)));
          set_has_coins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgRaisePour)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgRaisePour)
  return false;
#undef DO_
}

void MsgRaisePour::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgRaisePour)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional uint64 pour = 2;
  if (has_pour()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->pour(), output);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->coins(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgRaisePour)
}

::google::protobuf::uint8* MsgRaisePour::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgRaisePour)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional uint64 pour = 2;
  if (has_pour()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->pour(), target);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->coins(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgRaisePour)
  return target;
}

int MsgRaisePour::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional uint64 pour = 2;
    if (has_pour()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->pour());
    }

    // optional uint64 coins = 3;
    if (has_coins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->coins());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRaisePour::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRaisePour* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRaisePour*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRaisePour::MergeFrom(const MsgRaisePour& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_pour()) {
      set_pour(from.pour());
    }
    if (from.has_coins()) {
      set_coins(from.coins());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRaisePour::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRaisePour::CopyFrom(const MsgRaisePour& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRaisePour::IsInitialized() const {

  return true;
}

void MsgRaisePour::Swap(MsgRaisePour* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(pour_, other->pour_);
    std::swap(coins_, other->coins_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRaisePour::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRaisePour_descriptor_;
  metadata.reflection = MsgRaisePour_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRewardData::kRoleidFieldNumber;
const int MsgRewardData::kRewardFieldNumber;
const int MsgRewardData::kCoinsFieldNumber;
const int MsgRewardData::kMoneyFieldNumber;
const int MsgRewardData::kRankinFieldNumber;
const int MsgRewardData::kHandCardFieldNumber;
#endif  // !_MSC_VER

MsgRewardData::MsgRewardData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgRewardData)
}

void MsgRewardData::InitAsDefaultInstance() {
}

MsgRewardData::MsgRewardData(const MsgRewardData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgRewardData)
}

void MsgRewardData::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  reward_ = GOOGLE_ULONGLONG(0);
  coins_ = GOOGLE_ULONGLONG(0);
  money_ = GOOGLE_ULONGLONG(0);
  rankin_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRewardData::~MsgRewardData() {
  // @@protoc_insertion_point(destructor:MsgRewardData)
  SharedDtor();
}

void MsgRewardData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRewardData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRewardData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRewardData_descriptor_;
}

const MsgRewardData& MsgRewardData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgRewardData* MsgRewardData::default_instance_ = NULL;

MsgRewardData* MsgRewardData::New() const {
  return new MsgRewardData;
}

void MsgRewardData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRewardData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(roleid_, money_);
    rankin_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  hand_card_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRewardData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgRewardData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_reward;
        break;
      }

      // optional uint64 reward = 2;
      case 2: {
        if (tag == 16) {
         parse_reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_coins;
        break;
      }

      // optional uint64 coins = 3;
      case 3: {
        if (tag == 24) {
         parse_coins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &coins_)));
          set_has_coins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_money;
        break;
      }

      // optional uint64 money = 4;
      case 4: {
        if (tag == 32) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_rankin;
        break;
      }

      // optional uint32 rankin = 5;
      case 5: {
        if (tag == 40) {
         parse_rankin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rankin_)));
          set_has_rankin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_hand_card;
        break;
      }

      // repeated uint32 hand_card = 6;
      case 6: {
        if (tag == 48) {
         parse_hand_card:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 48, input, this->mutable_hand_card())));
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_hand_card())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_hand_card;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgRewardData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgRewardData)
  return false;
#undef DO_
}

void MsgRewardData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgRewardData)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional uint64 reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->reward(), output);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->coins(), output);
  }

  // optional uint64 money = 4;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->money(), output);
  }

  // optional uint32 rankin = 5;
  if (has_rankin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->rankin(), output);
  }

  // repeated uint32 hand_card = 6;
  for (int i = 0; i < this->hand_card_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      6, this->hand_card(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgRewardData)
}

::google::protobuf::uint8* MsgRewardData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgRewardData)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional uint64 reward = 2;
  if (has_reward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->reward(), target);
  }

  // optional uint64 coins = 3;
  if (has_coins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->coins(), target);
  }

  // optional uint64 money = 4;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->money(), target);
  }

  // optional uint32 rankin = 5;
  if (has_rankin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->rankin(), target);
  }

  // repeated uint32 hand_card = 6;
  for (int i = 0; i < this->hand_card_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(6, this->hand_card(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgRewardData)
  return target;
}

int MsgRewardData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional uint64 reward = 2;
    if (has_reward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->reward());
    }

    // optional uint64 coins = 3;
    if (has_coins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->coins());
    }

    // optional uint64 money = 4;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

    // optional uint32 rankin = 5;
    if (has_rankin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rankin());
    }

  }
  // repeated uint32 hand_card = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->hand_card_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->hand_card(i));
    }
    total_size += 1 * this->hand_card_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRewardData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRewardData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRewardData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRewardData::MergeFrom(const MsgRewardData& from) {
  GOOGLE_CHECK_NE(&from, this);
  hand_card_.MergeFrom(from.hand_card_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
    if (from.has_coins()) {
      set_coins(from.coins());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_rankin()) {
      set_rankin(from.rankin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRewardData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRewardData::CopyFrom(const MsgRewardData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRewardData::IsInitialized() const {

  return true;
}

void MsgRewardData::Swap(MsgRewardData* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(reward_, other->reward_);
    std::swap(coins_, other->coins_);
    std::swap(money_, other->money_);
    std::swap(rankin_, other->rankin_);
    hand_card_.Swap(&other->hand_card_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRewardData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRewardData_descriptor_;
  metadata.reflection = MsgRewardData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRewardList::kRewardFieldNumber;
const int MsgRewardList::kGobackFieldNumber;
const int MsgRewardList::kIsShowFieldNumber;
#endif  // !_MSC_VER

MsgRewardList::MsgRewardList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgRewardList)
}

void MsgRewardList::InitAsDefaultInstance() {
}

MsgRewardList::MsgRewardList(const MsgRewardList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgRewardList)
}

void MsgRewardList::SharedCtor() {
  _cached_size_ = 0;
  isshow_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRewardList::~MsgRewardList() {
  // @@protoc_insertion_point(destructor:MsgRewardList)
  SharedDtor();
}

void MsgRewardList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRewardList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRewardList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRewardList_descriptor_;
}

const MsgRewardList& MsgRewardList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgRewardList* MsgRewardList::default_instance_ = NULL;

MsgRewardList* MsgRewardList::New() const {
  return new MsgRewardList;
}

void MsgRewardList::Clear() {
  isshow_ = false;
  reward_.Clear();
  goback_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRewardList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgRewardList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MsgRewardData reward = 1;
      case 1: {
        if (tag == 10) {
         parse_reward:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_reward()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_reward;
        if (input->ExpectTag(18)) goto parse_goback;
        break;
      }

      // repeated .MsgRewardData goback = 2;
      case 2: {
        if (tag == 18) {
         parse_goback:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_goback()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_goback;
        if (input->ExpectTag(24)) goto parse_isShow;
        break;
      }

      // optional bool isShow = 3;
      case 3: {
        if (tag == 24) {
         parse_isShow:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isshow_)));
          set_has_isshow();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgRewardList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgRewardList)
  return false;
#undef DO_
}

void MsgRewardList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgRewardList)
  // repeated .MsgRewardData reward = 1;
  for (int i = 0; i < this->reward_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->reward(i), output);
  }

  // repeated .MsgRewardData goback = 2;
  for (int i = 0; i < this->goback_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->goback(i), output);
  }

  // optional bool isShow = 3;
  if (has_isshow()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isshow(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgRewardList)
}

::google::protobuf::uint8* MsgRewardList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgRewardList)
  // repeated .MsgRewardData reward = 1;
  for (int i = 0; i < this->reward_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->reward(i), target);
  }

  // repeated .MsgRewardData goback = 2;
  for (int i = 0; i < this->goback_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->goback(i), target);
  }

  // optional bool isShow = 3;
  if (has_isshow()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->isshow(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgRewardList)
  return target;
}

int MsgRewardList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional bool isShow = 3;
    if (has_isshow()) {
      total_size += 1 + 1;
    }

  }
  // repeated .MsgRewardData reward = 1;
  total_size += 1 * this->reward_size();
  for (int i = 0; i < this->reward_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reward(i));
  }

  // repeated .MsgRewardData goback = 2;
  total_size += 1 * this->goback_size();
  for (int i = 0; i < this->goback_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->goback(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRewardList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRewardList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRewardList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRewardList::MergeFrom(const MsgRewardList& from) {
  GOOGLE_CHECK_NE(&from, this);
  reward_.MergeFrom(from.reward_);
  goback_.MergeFrom(from.goback_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_isshow()) {
      set_isshow(from.isshow());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRewardList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRewardList::CopyFrom(const MsgRewardList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRewardList::IsInitialized() const {

  return true;
}

void MsgRewardList::Swap(MsgRewardList* other) {
  if (other != this) {
    reward_.Swap(&other->reward_);
    goback_.Swap(&other->goback_);
    std::swap(isshow_, other->isshow_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRewardList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRewardList_descriptor_;
  metadata.reflection = MsgRewardList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgResetCoins::kRoleidFieldNumber;
const int MsgResetCoins::kCoinsFieldNumber;
#endif  // !_MSC_VER

MsgResetCoins::MsgResetCoins()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgResetCoins)
}

void MsgResetCoins::InitAsDefaultInstance() {
}

MsgResetCoins::MsgResetCoins(const MsgResetCoins& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgResetCoins)
}

void MsgResetCoins::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  coins_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgResetCoins::~MsgResetCoins() {
  // @@protoc_insertion_point(destructor:MsgResetCoins)
  SharedDtor();
}

void MsgResetCoins::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgResetCoins::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgResetCoins::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgResetCoins_descriptor_;
}

const MsgResetCoins& MsgResetCoins::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgResetCoins* MsgResetCoins::default_instance_ = NULL;

MsgResetCoins* MsgResetCoins::New() const {
  return new MsgResetCoins;
}

void MsgResetCoins::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgResetCoins*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roleid_, coins_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgResetCoins::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgResetCoins)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_coins;
        break;
      }

      // optional uint64 coins = 2;
      case 2: {
        if (tag == 16) {
         parse_coins:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &coins_)));
          set_has_coins();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgResetCoins)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgResetCoins)
  return false;
#undef DO_
}

void MsgResetCoins::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgResetCoins)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional uint64 coins = 2;
  if (has_coins()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->coins(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgResetCoins)
}

::google::protobuf::uint8* MsgResetCoins::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgResetCoins)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional uint64 coins = 2;
  if (has_coins()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->coins(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgResetCoins)
  return target;
}

int MsgResetCoins::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional uint64 coins = 2;
    if (has_coins()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->coins());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgResetCoins::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgResetCoins* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgResetCoins*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgResetCoins::MergeFrom(const MsgResetCoins& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_coins()) {
      set_coins(from.coins());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgResetCoins::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgResetCoins::CopyFrom(const MsgResetCoins& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgResetCoins::IsInitialized() const {

  return true;
}

void MsgResetCoins::Swap(MsgResetCoins* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(coins_, other->coins_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgResetCoins::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgResetCoins_descriptor_;
  metadata.reflection = MsgResetCoins_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgApplyGame::kRoomTypeFieldNumber;
const int MsgApplyGame::kTimeidFieldNumber;
const int MsgApplyGame::kMoneyFieldNumber;
#endif  // !_MSC_VER

MsgApplyGame::MsgApplyGame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgApplyGame)
}

void MsgApplyGame::InitAsDefaultInstance() {
}

MsgApplyGame::MsgApplyGame(const MsgApplyGame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgApplyGame)
}

void MsgApplyGame::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  room_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timeid_ = 0u;
  money_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgApplyGame::~MsgApplyGame() {
  // @@protoc_insertion_point(destructor:MsgApplyGame)
  SharedDtor();
}

void MsgApplyGame::SharedDtor() {
  if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete room_type_;
  }
  if (this != default_instance_) {
  }
}

void MsgApplyGame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgApplyGame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgApplyGame_descriptor_;
}

const MsgApplyGame& MsgApplyGame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgApplyGame* MsgApplyGame::default_instance_ = NULL;

MsgApplyGame* MsgApplyGame::New() const {
  return new MsgApplyGame;
}

void MsgApplyGame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgApplyGame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(money_, timeid_);
    if (has_room_type()) {
      if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        room_type_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgApplyGame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgApplyGame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string room_type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_room_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->room_type().data(), this->room_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "room_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_timeid;
        break;
      }

      // optional uint32 timeid = 2;
      case 2: {
        if (tag == 16) {
         parse_timeid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeid_)));
          set_has_timeid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional uint64 money = 3;
      case 3: {
        if (tag == 24) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgApplyGame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgApplyGame)
  return false;
#undef DO_
}

void MsgApplyGame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgApplyGame)
  // optional string room_type = 1;
  if (has_room_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->room_type().data(), this->room_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "room_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->room_type(), output);
  }

  // optional uint32 timeid = 2;
  if (has_timeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->timeid(), output);
  }

  // optional uint64 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->money(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgApplyGame)
}

::google::protobuf::uint8* MsgApplyGame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgApplyGame)
  // optional string room_type = 1;
  if (has_room_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->room_type().data(), this->room_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "room_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->room_type(), target);
  }

  // optional uint32 timeid = 2;
  if (has_timeid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->timeid(), target);
  }

  // optional uint64 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->money(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgApplyGame)
  return target;
}

int MsgApplyGame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string room_type = 1;
    if (has_room_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->room_type());
    }

    // optional uint32 timeid = 2;
    if (has_timeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeid());
    }

    // optional uint64 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgApplyGame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgApplyGame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgApplyGame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgApplyGame::MergeFrom(const MsgApplyGame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_type()) {
      set_room_type(from.room_type());
    }
    if (from.has_timeid()) {
      set_timeid(from.timeid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgApplyGame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgApplyGame::CopyFrom(const MsgApplyGame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgApplyGame::IsInitialized() const {

  return true;
}

void MsgApplyGame::Swap(MsgApplyGame* other) {
  if (other != this) {
    std::swap(room_type_, other->room_type_);
    std::swap(timeid_, other->timeid_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgApplyGame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgApplyGame_descriptor_;
  metadata.reflection = MsgApplyGame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgCancelApply::kRoomTypeFieldNumber;
const int MsgCancelApply::kTimeidFieldNumber;
const int MsgCancelApply::kMoneyFieldNumber;
#endif  // !_MSC_VER

MsgCancelApply::MsgCancelApply()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgCancelApply)
}

void MsgCancelApply::InitAsDefaultInstance() {
}

MsgCancelApply::MsgCancelApply(const MsgCancelApply& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgCancelApply)
}

void MsgCancelApply::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  room_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timeid_ = 0u;
  money_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgCancelApply::~MsgCancelApply() {
  // @@protoc_insertion_point(destructor:MsgCancelApply)
  SharedDtor();
}

void MsgCancelApply::SharedDtor() {
  if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete room_type_;
  }
  if (this != default_instance_) {
  }
}

void MsgCancelApply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgCancelApply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgCancelApply_descriptor_;
}

const MsgCancelApply& MsgCancelApply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgCancelApply* MsgCancelApply::default_instance_ = NULL;

MsgCancelApply* MsgCancelApply::New() const {
  return new MsgCancelApply;
}

void MsgCancelApply::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgCancelApply*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(money_, timeid_);
    if (has_room_type()) {
      if (room_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        room_type_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgCancelApply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgCancelApply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string room_type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_room_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->room_type().data(), this->room_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "room_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_timeid;
        break;
      }

      // optional uint32 timeid = 2;
      case 2: {
        if (tag == 16) {
         parse_timeid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeid_)));
          set_has_timeid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional uint64 money = 3;
      case 3: {
        if (tag == 24) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgCancelApply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgCancelApply)
  return false;
#undef DO_
}

void MsgCancelApply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgCancelApply)
  // optional string room_type = 1;
  if (has_room_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->room_type().data(), this->room_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "room_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->room_type(), output);
  }

  // optional uint32 timeid = 2;
  if (has_timeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->timeid(), output);
  }

  // optional uint64 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->money(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgCancelApply)
}

::google::protobuf::uint8* MsgCancelApply::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgCancelApply)
  // optional string room_type = 1;
  if (has_room_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->room_type().data(), this->room_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "room_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->room_type(), target);
  }

  // optional uint32 timeid = 2;
  if (has_timeid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->timeid(), target);
  }

  // optional uint64 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->money(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgCancelApply)
  return target;
}

int MsgCancelApply::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string room_type = 1;
    if (has_room_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->room_type());
    }

    // optional uint32 timeid = 2;
    if (has_timeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timeid());
    }

    // optional uint64 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgCancelApply::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgCancelApply* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgCancelApply*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgCancelApply::MergeFrom(const MsgCancelApply& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_type()) {
      set_room_type(from.room_type());
    }
    if (from.has_timeid()) {
      set_timeid(from.timeid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgCancelApply::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgCancelApply::CopyFrom(const MsgCancelApply& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgCancelApply::IsInitialized() const {

  return true;
}

void MsgCancelApply::Swap(MsgCancelApply* other) {
  if (other != this) {
    std::swap(room_type_, other->room_type_);
    std::swap(timeid_, other->timeid_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgCancelApply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgCancelApply_descriptor_;
  metadata.reflection = MsgCancelApply_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgRequestQuit::kRankingFieldNumber;
const int MsgRequestQuit::kRewardFieldNumber;
#endif  // !_MSC_VER

MsgRequestQuit::MsgRequestQuit()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgRequestQuit)
}

void MsgRequestQuit::InitAsDefaultInstance() {
}

MsgRequestQuit::MsgRequestQuit(const MsgRequestQuit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgRequestQuit)
}

void MsgRequestQuit::SharedCtor() {
  _cached_size_ = 0;
  ranking_ = 0u;
  reward_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgRequestQuit::~MsgRequestQuit() {
  // @@protoc_insertion_point(destructor:MsgRequestQuit)
  SharedDtor();
}

void MsgRequestQuit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgRequestQuit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgRequestQuit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgRequestQuit_descriptor_;
}

const MsgRequestQuit& MsgRequestQuit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5ftexaspoker_2eproto();
  return *default_instance_;
}

MsgRequestQuit* MsgRequestQuit::default_instance_ = NULL;

MsgRequestQuit* MsgRequestQuit::New() const {
  return new MsgRequestQuit;
}

void MsgRequestQuit::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgRequestQuit*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ranking_, reward_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgRequestQuit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgRequestQuit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ranking = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ranking_)));
          set_has_ranking();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_reward;
        break;
      }

      // optional bool reward = 2;
      case 2: {
        if (tag == 16) {
         parse_reward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reward_)));
          set_has_reward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgRequestQuit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgRequestQuit)
  return false;
#undef DO_
}

void MsgRequestQuit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgRequestQuit)
  // optional uint32 ranking = 1;
  if (has_ranking()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ranking(), output);
  }

  // optional bool reward = 2;
  if (has_reward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->reward(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgRequestQuit)
}

::google::protobuf::uint8* MsgRequestQuit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgRequestQuit)
  // optional uint32 ranking = 1;
  if (has_ranking()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ranking(), target);
  }

  // optional bool reward = 2;
  if (has_reward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->reward(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgRequestQuit)
  return target;
}

int MsgRequestQuit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ranking = 1;
    if (has_ranking()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ranking());
    }

    // optional bool reward = 2;
    if (has_reward()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgRequestQuit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgRequestQuit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgRequestQuit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgRequestQuit::MergeFrom(const MsgRequestQuit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ranking()) {
      set_ranking(from.ranking());
    }
    if (from.has_reward()) {
      set_reward(from.reward());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgRequestQuit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgRequestQuit::CopyFrom(const MsgRequestQuit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgRequestQuit::IsInitialized() const {

  return true;
}

void MsgRequestQuit::Swap(MsgRequestQuit* other) {
  if (other != this) {
    std::swap(ranking_, other->ranking_);
    std::swap(reward_, other->reward_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgRequestQuit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgRequestQuit_descriptor_;
  metadata.reflection = MsgRequestQuit_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
