// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_chess.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "msg_chess.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MsgChessPlayer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessPlayer_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessMove_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessMove_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessAction_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessAction_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessChessManual_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessChessManual_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessItemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessItemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessRoom_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessRoom_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessGameOverInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessGameOverInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessShowDown_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessShowDown_reflection_ = NULL;
const ::google::protobuf::Descriptor* MsgChessIntegralCount_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MsgChessIntegralCount_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessPlayerState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessPlayerWik_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessColor_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessShow_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TChessStepState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_msg_5fchess_2eproto() {
  protobuf_AddDesc_msg_5fchess_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "msg_chess.proto");
  GOOGLE_CHECK(file != NULL);
  MsgChessPlayer_descriptor_ = file->message_type(0);
  static const int MsgChessPlayer_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, player_base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, seats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, score_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, overinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, regret_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, chess_item_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, eatchess_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, innings_time_),
  };
  MsgChessPlayer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessPlayer_descriptor_,
      MsgChessPlayer::default_instance_,
      MsgChessPlayer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessPlayer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessPlayer));
  MsgChessMove_descriptor_ = file->message_type(1);
  static const int MsgChessMove_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, source_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, source_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, target_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, target_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, is_kill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, is_checkmate_),
  };
  MsgChessMove_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessMove_descriptor_,
      MsgChessMove::default_instance_,
      MsgChessMove_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessMove, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessMove));
  MsgChessAction_descriptor_ = file->message_type(2);
  static const int MsgChessAction_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, action_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, action_wik_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, regret_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, last_chess_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, player_list_),
  };
  MsgChessAction_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessAction_descriptor_,
      MsgChessAction::default_instance_,
      MsgChessAction_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessAction, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessAction));
  MsgChessChessManual_descriptor_ = file->message_type(3);
  static const int MsgChessChessManual_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, target_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, target_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, source_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, source_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, source_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, chess_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, chess_target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, target_id_),
  };
  MsgChessChessManual_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessChessManual_descriptor_,
      MsgChessChessManual::default_instance_,
      MsgChessChessManual_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessChessManual, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessChessManual));
  MsgChessItemInfo_descriptor_ = file->message_type(4);
  static const int MsgChessItemInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, position_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, position_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, chess_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, showchess_),
  };
  MsgChessItemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessItemInfo_descriptor_,
      MsgChessItemInfo::default_instance_,
      MsgChessItemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessItemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessItemInfo));
  MsgChessRoom_descriptor_ = file->message_type(5);
  static const int MsgChessRoom_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, room_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, state_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, player_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, room_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, game_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, private_room_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, role_host_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, role_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, relieve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, room_pay_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, action_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, wiki_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, last_chess_),
  };
  MsgChessRoom_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessRoom_descriptor_,
      MsgChessRoom::default_instance_,
      MsgChessRoom_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessRoom, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessRoom));
  MsgChessGameOverInfo_descriptor_ = file->message_type(6);
  static const int MsgChessGameOverInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessGameOverInfo, win_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessGameOverInfo, lose_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessGameOverInfo, peace_count_),
  };
  MsgChessGameOverInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessGameOverInfo_descriptor_,
      MsgChessGameOverInfo::default_instance_,
      MsgChessGameOverInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessGameOverInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessGameOverInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessGameOverInfo));
  MsgChessShowDown_descriptor_ = file->message_type(7);
  static const int MsgChessShowDown_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, room_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, state_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, player_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, room_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, win_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, game_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, game_over_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, integral_list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, last_chess_),
  };
  MsgChessShowDown_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessShowDown_descriptor_,
      MsgChessShowDown::default_instance_,
      MsgChessShowDown_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessShowDown, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessShowDown));
  MsgChessIntegralCount_descriptor_ = file->message_type(8);
  static const int MsgChessIntegralCount_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessIntegralCount, roleid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessIntegralCount, count_),
  };
  MsgChessIntegralCount_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MsgChessIntegralCount_descriptor_,
      MsgChessIntegralCount::default_instance_,
      MsgChessIntegralCount_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessIntegralCount, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MsgChessIntegralCount, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MsgChessIntegralCount));
  TChessState_descriptor_ = file->enum_type(0);
  TChessPlayerState_descriptor_ = file->enum_type(1);
  TChessPlayerWik_descriptor_ = file->enum_type(2);
  TChessType_descriptor_ = file->enum_type(3);
  TChessColor_descriptor_ = file->enum_type(4);
  TChessShow_descriptor_ = file->enum_type(5);
  TChessStepState_descriptor_ = file->enum_type(6);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_msg_5fchess_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessPlayer_descriptor_, &MsgChessPlayer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessMove_descriptor_, &MsgChessMove::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessAction_descriptor_, &MsgChessAction::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessChessManual_descriptor_, &MsgChessChessManual::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessItemInfo_descriptor_, &MsgChessItemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessRoom_descriptor_, &MsgChessRoom::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessGameOverInfo_descriptor_, &MsgChessGameOverInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessShowDown_descriptor_, &MsgChessShowDown::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MsgChessIntegralCount_descriptor_, &MsgChessIntegralCount::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_msg_5fchess_2eproto() {
  delete MsgChessPlayer::default_instance_;
  delete MsgChessPlayer_reflection_;
  delete MsgChessMove::default_instance_;
  delete MsgChessMove_reflection_;
  delete MsgChessAction::default_instance_;
  delete MsgChessAction_reflection_;
  delete MsgChessChessManual::default_instance_;
  delete MsgChessChessManual_reflection_;
  delete MsgChessItemInfo::default_instance_;
  delete MsgChessItemInfo_reflection_;
  delete MsgChessRoom::default_instance_;
  delete MsgChessRoom_reflection_;
  delete MsgChessGameOverInfo::default_instance_;
  delete MsgChessGameOverInfo_reflection_;
  delete MsgChessShowDown::default_instance_;
  delete MsgChessShowDown_reflection_;
  delete MsgChessIntegralCount::default_instance_;
  delete MsgChessIntegralCount_reflection_;
}

void protobuf_AddDesc_msg_5fchess_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_public_5fpro_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017msg_chess.proto\032\020public_pro.proto\"\237\002\n\016"
    "MsgChessPlayer\022#\n\013player_base\030\001 \001(\0132\016.Ms"
    "gPlayerInfo\022\r\n\005seats\030\002 \001(\r\022\r\n\005score\030\003 \001("
    "\003\022\'\n\010overInfo\030\004 \001(\0132\025.MsgChessGameOverIn"
    "fo\022\033\n\005color\030\005 \001(\0162\014.TChessColor\022\024\n\014regre"
    "t_count\030\006 \001(\r\022%\n\nchess_item\030\007 \003(\0132\021.MsgC"
    "hessItemInfo\022\r\n\005state\030\010 \001(\r\022\"\n\reatchess_"
    "list\030\t \003(\0162\013.TChessType\022\024\n\014innings_time\030"
    "\n \001(\r\"\211\001\n\014MsgChessMove\022\n\n\002id\030\001 \001(\004\022\020\n\010So"
    "urce_X\030\002 \001(\r\022\020\n\010Source_Y\030\003 \001(\r\022\020\n\010Target"
    "_X\030\004 \001(\r\022\020\n\010Target_Y\030\005 \001(\r\022\017\n\007is_kill\030\006 "
    "\001(\010\022\024\n\014is_checkmate\030\007 \001(\010\"\235\001\n\016MsgChessAc"
    "tion\022\021\n\taction_id\030\001 \001(\004\022\022\n\naction_wik\030\002 "
    "\001(\r\022\024\n\014regret_count\030\003 \001(\r\022(\n\nlast_chess\030"
    "\004 \001(\0132\024.MsgChessChessManual\022$\n\013player_li"
    "st\030\005 \003(\0132\017.MsgChessPlayer\"\344\001\n\023MsgChessCh"
    "essManual\022\020\n\010target_x\030\001 \001(\r\022\020\n\010target_y\030"
    "\002 \001(\r\022\020\n\010source_x\030\003 \001(\r\022\020\n\010source_y\030\004 \001("
    "\r\022\021\n\tsource_id\030\005 \001(\r\022\033\n\005color\030\006 \001(\0162\014.TC"
    "hessColor\022\037\n\nchess_type\030\007 \001(\0162\013.TChessTy"
    "pe\022!\n\014chess_target\030\010 \001(\0162\013.TChessType\022\021\n"
    "\ttarget_id\030\t \001(\r\"{\n\020MsgChessItemInfo\022\022\n\n"
    "position_x\030\001 \001(\r\022\022\n\nposition_y\030\002 \001(\r\022\037\n\n"
    "chess_type\030\003 \001(\0162\013.TChessType\022\036\n\tshowche"
    "ss\030\004 \001(\0162\013.TChessShow\"\375\002\n\014MsgChessRoom\022 "
    "\n\nroom_state\030\001 \001(\0162\014.TChessState\022\022\n\nstat"
    "e_time\030\002 \001(\r\022$\n\013player_list\030\003 \003(\0132\017.MsgC"
    "hessPlayer\022\017\n\007room_id\030\004 \001(\004\022\022\n\ngame_coun"
    "t\030\005 \001(\r\022+\n\014private_room\030\006 \001(\0132\025.MsgCreat"
    "ePrivateRoom\022$\n\trole_host\030\007 \001(\0132\021.MsgRol"
    "eHostCount\022&\n\nrole_state\030\010 \001(\0132\022.MsgRole"
    "StateCount\022\017\n\007relieve\030\t \001(\010\022\025\n\rroom_pay_"
    "type\030\n \001(\r\022\021\n\taction_id\030\013 \001(\004\022\014\n\004wiki\030\014 "
    "\001(\r\022(\n\nlast_chess\030\r \001(\0132\024.MsgChessChessM"
    "anual\"R\n\024MsgChessGameOverInfo\022\021\n\twin_cou"
    "nt\030\001 \001(\r\022\022\n\nlose_count\030\002 \001(\r\022\023\n\013peace_co"
    "unt\030\003 \001(\r\"\235\002\n\020MsgChessShowDown\022 \n\nroom_s"
    "tate\030\001 \001(\0162\014.TChessState\022\022\n\nstate_time\030\002"
    " \001(\r\022$\n\013player_list\030\003 \003(\0132\017.MsgChessPlay"
    "er\022\017\n\007room_id\030\004 \001(\004\022\016\n\006win_id\030\005 \001(\004\022\022\n\ng"
    "ame_count\030\006 \001(\r\022\014\n\004time\030\007 \001(\r\022\021\n\tgame_ov"
    "er\030\010 \001(\010\022-\n\rintegral_list\030\t \003(\0132\026.MsgChe"
    "ssIntegralCount\022(\n\nlast_chess\030\n \001(\0132\024.Ms"
    "gChessChessManual\"6\n\025MsgChessIntegralCou"
    "nt\022\016\n\006roleid\030\001 \001(\004\022\r\n\005count\030\002 \001(\r*\336\001\n\013TC"
    "hessState\022\023\n\017TChessStateWait\020\000\022\035\n\031TChess"
    "StateCheckStartGame\020\001\022\030\n\024TChessStateStar"
    "tGame\020\002\022\025\n\021TChessStateAction\020\003\022\027\n\023TChess"
    "StateAskPeace\020\004\022\034\n\030TChessStateAskUndoAct"
    "ion\020\005\022\027\n\023TChessStateShowDown\020\006\022\032\n\026TChess"
    "StateRelieveRoom\020\007*\307\001\n\021TChessPlayerState"
    "\022\022\n\016STATE_CS_READY\020\001\022\024\n\020STATE_CS_NEWROLE"
    "\020\002\022\027\n\023STATE_CS_ROOM_OWNER\020\004\022\024\n\020STATE_CS_"
    "RELIEVE\020\010\022\022\n\016STATE_CS_LEAVE\020\020\022\022\n\016STATE_C"
    "S_LIMIT\020 \022\024\n\020STATE_CS_OFFLINE\020@\022\033\n\026STATE"
    "_CS_CONTINUE_GAME\020\200\001*b\n\017TChessPlayerWik\022"
    "\017\n\013CS_WIK_NULL\020\001\022\023\n\017CS_WIK_ASKPEACE\020\002\022\025\n"
    "\021CS_WIK_UNDOACTION\020\004\022\022\n\016CS_WIK_ASKLOSE\020\010"
    "*\240\001\n\nTChessType\022\023\n\017CHESS_TYPE_NULL\020\000\022\021\n\r"
    "CHESS_GENERAL\020\001\022\020\n\014CHESS_KAVASS\020\002\022\022\n\016CHE"
    "SS_ELEPHANT\020\003\022\017\n\013CHESS_HORSE\020\004\022\016\n\nCHESS_"
    "ROOK\020\005\022\020\n\014CHESS_CANNON\020\006\022\021\n\rCHESS_SOLDIE"
    "R\020\007*=\n\013TChessColor\022\016\n\nCHESS_NULL\020\000\022\017\n\013CH"
    "ESS_BLACK\020\001\022\r\n\tCHESS_RED\020\002*L\n\nTChessShow"
    "\022\023\n\017CHESS_SHOW_NULL\020\000\022\023\n\017CHESS_SHOW_OPEN"
    "\020\001\022\024\n\020CHESS_SHOW_CLOSE\020\002*f\n\017TChessStepSt"
    "ate\022\023\n\017CHESS_STEP_NULL\020\000\022\024\n\020CHESS_STEP_C"
    "HECK\020\001\022\024\n\020CHESS_STEP_CATCH\020\002\022\022\n\016CHESS_ST"
    "EP_EAT\020\003", 2728);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "msg_chess.proto", &protobuf_RegisterTypes);
  MsgChessPlayer::default_instance_ = new MsgChessPlayer();
  MsgChessMove::default_instance_ = new MsgChessMove();
  MsgChessAction::default_instance_ = new MsgChessAction();
  MsgChessChessManual::default_instance_ = new MsgChessChessManual();
  MsgChessItemInfo::default_instance_ = new MsgChessItemInfo();
  MsgChessRoom::default_instance_ = new MsgChessRoom();
  MsgChessGameOverInfo::default_instance_ = new MsgChessGameOverInfo();
  MsgChessShowDown::default_instance_ = new MsgChessShowDown();
  MsgChessIntegralCount::default_instance_ = new MsgChessIntegralCount();
  MsgChessPlayer::default_instance_->InitAsDefaultInstance();
  MsgChessMove::default_instance_->InitAsDefaultInstance();
  MsgChessAction::default_instance_->InitAsDefaultInstance();
  MsgChessChessManual::default_instance_->InitAsDefaultInstance();
  MsgChessItemInfo::default_instance_->InitAsDefaultInstance();
  MsgChessRoom::default_instance_->InitAsDefaultInstance();
  MsgChessGameOverInfo::default_instance_->InitAsDefaultInstance();
  MsgChessShowDown::default_instance_->InitAsDefaultInstance();
  MsgChessIntegralCount::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_msg_5fchess_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_msg_5fchess_2eproto {
  StaticDescriptorInitializer_msg_5fchess_2eproto() {
    protobuf_AddDesc_msg_5fchess_2eproto();
  }
} static_descriptor_initializer_msg_5fchess_2eproto_;
const ::google::protobuf::EnumDescriptor* TChessState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessState_descriptor_;
}
bool TChessState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessPlayerState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessPlayerState_descriptor_;
}
bool TChessPlayerState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessPlayerWik_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessPlayerWik_descriptor_;
}
bool TChessPlayerWik_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessType_descriptor_;
}
bool TChessType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessColor_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessColor_descriptor_;
}
bool TChessColor_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessShow_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessShow_descriptor_;
}
bool TChessShow_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TChessStepState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TChessStepState_descriptor_;
}
bool TChessStepState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessPlayer::kPlayerBaseFieldNumber;
const int MsgChessPlayer::kSeatsFieldNumber;
const int MsgChessPlayer::kScoreFieldNumber;
const int MsgChessPlayer::kOverInfoFieldNumber;
const int MsgChessPlayer::kColorFieldNumber;
const int MsgChessPlayer::kRegretCountFieldNumber;
const int MsgChessPlayer::kChessItemFieldNumber;
const int MsgChessPlayer::kStateFieldNumber;
const int MsgChessPlayer::kEatchessListFieldNumber;
const int MsgChessPlayer::kInningsTimeFieldNumber;
#endif  // !_MSC_VER

MsgChessPlayer::MsgChessPlayer()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessPlayer)
}

void MsgChessPlayer::InitAsDefaultInstance() {
  player_base_ = const_cast< ::MsgPlayerInfo*>(&::MsgPlayerInfo::default_instance());
  overinfo_ = const_cast< ::MsgChessGameOverInfo*>(&::MsgChessGameOverInfo::default_instance());
}

MsgChessPlayer::MsgChessPlayer(const MsgChessPlayer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessPlayer)
}

void MsgChessPlayer::SharedCtor() {
  _cached_size_ = 0;
  player_base_ = NULL;
  seats_ = 0u;
  score_ = GOOGLE_LONGLONG(0);
  overinfo_ = NULL;
  color_ = 0;
  regret_count_ = 0u;
  state_ = 0u;
  innings_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessPlayer::~MsgChessPlayer() {
  // @@protoc_insertion_point(destructor:MsgChessPlayer)
  SharedDtor();
}

void MsgChessPlayer::SharedDtor() {
  if (this != default_instance_) {
    delete player_base_;
    delete overinfo_;
  }
}

void MsgChessPlayer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessPlayer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessPlayer_descriptor_;
}

const MsgChessPlayer& MsgChessPlayer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessPlayer* MsgChessPlayer::default_instance_ = NULL;

MsgChessPlayer* MsgChessPlayer::New() const {
  return new MsgChessPlayer;
}

void MsgChessPlayer::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessPlayer*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 191) {
    ZR_(score_, color_);
    ZR_(regret_count_, state_);
    if (has_player_base()) {
      if (player_base_ != NULL) player_base_->::MsgPlayerInfo::Clear();
    }
    if (has_overinfo()) {
      if (overinfo_ != NULL) overinfo_->::MsgChessGameOverInfo::Clear();
    }
  }
  innings_time_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  chess_item_.Clear();
  eatchess_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessPlayer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessPlayer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MsgPlayerInfo player_base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_seats;
        break;
      }

      // optional uint32 seats = 2;
      case 2: {
        if (tag == 16) {
         parse_seats:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seats_)));
          set_has_seats();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_score;
        break;
      }

      // optional int64 score = 3;
      case 3: {
        if (tag == 24) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &score_)));
          set_has_score();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_overInfo;
        break;
      }

      // optional .MsgChessGameOverInfo overInfo = 4;
      case 4: {
        if (tag == 34) {
         parse_overInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_overinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_color;
        break;
      }

      // optional .TChessColor color = 5;
      case 5: {
        if (tag == 40) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessColor_IsValid(value)) {
            set_color(static_cast< ::TChessColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_regret_count;
        break;
      }

      // optional uint32 regret_count = 6;
      case 6: {
        if (tag == 48) {
         parse_regret_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &regret_count_)));
          set_has_regret_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_chess_item;
        break;
      }

      // repeated .MsgChessItemInfo chess_item = 7;
      case 7: {
        if (tag == 58) {
         parse_chess_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_chess_item()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_chess_item;
        if (input->ExpectTag(64)) goto parse_state;
        break;
      }

      // optional uint32 state = 8;
      case 8: {
        if (tag == 64) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_eatchess_list;
        break;
      }

      // repeated .TChessType eatchess_list = 9;
      case 9: {
        if (tag == 72) {
         parse_eatchess_list:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessType_IsValid(value)) {
            add_eatchess_list(static_cast< ::TChessType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else if (tag == 74) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumNoInline(
                 input,
                 &::TChessType_IsValid,
                 this->mutable_eatchess_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_eatchess_list;
        if (input->ExpectTag(80)) goto parse_innings_time;
        break;
      }

      // optional uint32 innings_time = 10;
      case 10: {
        if (tag == 80) {
         parse_innings_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &innings_time_)));
          set_has_innings_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessPlayer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessPlayer)
  return false;
#undef DO_
}

void MsgChessPlayer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessPlayer)
  // optional .MsgPlayerInfo player_base = 1;
  if (has_player_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->player_base(), output);
  }

  // optional uint32 seats = 2;
  if (has_seats()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->seats(), output);
  }

  // optional int64 score = 3;
  if (has_score()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->score(), output);
  }

  // optional .MsgChessGameOverInfo overInfo = 4;
  if (has_overinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->overinfo(), output);
  }

  // optional .TChessColor color = 5;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->color(), output);
  }

  // optional uint32 regret_count = 6;
  if (has_regret_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->regret_count(), output);
  }

  // repeated .MsgChessItemInfo chess_item = 7;
  for (int i = 0; i < this->chess_item_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->chess_item(i), output);
  }

  // optional uint32 state = 8;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->state(), output);
  }

  // repeated .TChessType eatchess_list = 9;
  for (int i = 0; i < this->eatchess_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->eatchess_list(i), output);
  }

  // optional uint32 innings_time = 10;
  if (has_innings_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->innings_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessPlayer)
}

::google::protobuf::uint8* MsgChessPlayer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessPlayer)
  // optional .MsgPlayerInfo player_base = 1;
  if (has_player_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->player_base(), target);
  }

  // optional uint32 seats = 2;
  if (has_seats()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->seats(), target);
  }

  // optional int64 score = 3;
  if (has_score()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->score(), target);
  }

  // optional .MsgChessGameOverInfo overInfo = 4;
  if (has_overinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->overinfo(), target);
  }

  // optional .TChessColor color = 5;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->color(), target);
  }

  // optional uint32 regret_count = 6;
  if (has_regret_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->regret_count(), target);
  }

  // repeated .MsgChessItemInfo chess_item = 7;
  for (int i = 0; i < this->chess_item_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->chess_item(i), target);
  }

  // optional uint32 state = 8;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->state(), target);
  }

  // repeated .TChessType eatchess_list = 9;
  for (int i = 0; i < this->eatchess_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->eatchess_list(i), target);
  }

  // optional uint32 innings_time = 10;
  if (has_innings_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->innings_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessPlayer)
  return target;
}

int MsgChessPlayer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MsgPlayerInfo player_base = 1;
    if (has_player_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->player_base());
    }

    // optional uint32 seats = 2;
    if (has_seats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seats());
    }

    // optional int64 score = 3;
    if (has_score()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->score());
    }

    // optional .MsgChessGameOverInfo overInfo = 4;
    if (has_overinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->overinfo());
    }

    // optional .TChessColor color = 5;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

    // optional uint32 regret_count = 6;
    if (has_regret_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->regret_count());
    }

    // optional uint32 state = 8;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional uint32 innings_time = 10;
    if (has_innings_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->innings_time());
    }

  }
  // repeated .MsgChessItemInfo chess_item = 7;
  total_size += 1 * this->chess_item_size();
  for (int i = 0; i < this->chess_item_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chess_item(i));
  }

  // repeated .TChessType eatchess_list = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->eatchess_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->eatchess_list(i));
    }
    total_size += 1 * this->eatchess_list_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessPlayer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessPlayer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessPlayer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessPlayer::MergeFrom(const MsgChessPlayer& from) {
  GOOGLE_CHECK_NE(&from, this);
  chess_item_.MergeFrom(from.chess_item_);
  eatchess_list_.MergeFrom(from.eatchess_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_player_base()) {
      mutable_player_base()->::MsgPlayerInfo::MergeFrom(from.player_base());
    }
    if (from.has_seats()) {
      set_seats(from.seats());
    }
    if (from.has_score()) {
      set_score(from.score());
    }
    if (from.has_overinfo()) {
      mutable_overinfo()->::MsgChessGameOverInfo::MergeFrom(from.overinfo());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_regret_count()) {
      set_regret_count(from.regret_count());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_innings_time()) {
      set_innings_time(from.innings_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessPlayer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessPlayer::CopyFrom(const MsgChessPlayer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessPlayer::IsInitialized() const {

  return true;
}

void MsgChessPlayer::Swap(MsgChessPlayer* other) {
  if (other != this) {
    std::swap(player_base_, other->player_base_);
    std::swap(seats_, other->seats_);
    std::swap(score_, other->score_);
    std::swap(overinfo_, other->overinfo_);
    std::swap(color_, other->color_);
    std::swap(regret_count_, other->regret_count_);
    chess_item_.Swap(&other->chess_item_);
    std::swap(state_, other->state_);
    eatchess_list_.Swap(&other->eatchess_list_);
    std::swap(innings_time_, other->innings_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessPlayer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessPlayer_descriptor_;
  metadata.reflection = MsgChessPlayer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessMove::kIdFieldNumber;
const int MsgChessMove::kSourceXFieldNumber;
const int MsgChessMove::kSourceYFieldNumber;
const int MsgChessMove::kTargetXFieldNumber;
const int MsgChessMove::kTargetYFieldNumber;
const int MsgChessMove::kIsKillFieldNumber;
const int MsgChessMove::kIsCheckmateFieldNumber;
#endif  // !_MSC_VER

MsgChessMove::MsgChessMove()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessMove)
}

void MsgChessMove::InitAsDefaultInstance() {
}

MsgChessMove::MsgChessMove(const MsgChessMove& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessMove)
}

void MsgChessMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_ULONGLONG(0);
  source_x_ = 0u;
  source_y_ = 0u;
  target_x_ = 0u;
  target_y_ = 0u;
  is_kill_ = false;
  is_checkmate_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessMove::~MsgChessMove() {
  // @@protoc_insertion_point(destructor:MsgChessMove)
  SharedDtor();
}

void MsgChessMove::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgChessMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessMove::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessMove_descriptor_;
}

const MsgChessMove& MsgChessMove::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessMove* MsgChessMove::default_instance_ = NULL;

MsgChessMove* MsgChessMove::New() const {
  return new MsgChessMove;
}

void MsgChessMove::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessMove*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(id_, is_checkmate_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessMove)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_Source_X;
        break;
      }

      // optional uint32 Source_X = 2;
      case 2: {
        if (tag == 16) {
         parse_Source_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_x_)));
          set_has_source_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Source_Y;
        break;
      }

      // optional uint32 Source_Y = 3;
      case 3: {
        if (tag == 24) {
         parse_Source_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_y_)));
          set_has_source_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Target_X;
        break;
      }

      // optional uint32 Target_X = 4;
      case 4: {
        if (tag == 32) {
         parse_Target_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_x_)));
          set_has_target_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Target_Y;
        break;
      }

      // optional uint32 Target_Y = 5;
      case 5: {
        if (tag == 40) {
         parse_Target_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_y_)));
          set_has_target_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_is_kill;
        break;
      }

      // optional bool is_kill = 6;
      case 6: {
        if (tag == 48) {
         parse_is_kill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_kill_)));
          set_has_is_kill();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_is_checkmate;
        break;
      }

      // optional bool is_checkmate = 7;
      case 7: {
        if (tag == 56) {
         parse_is_checkmate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_checkmate_)));
          set_has_is_checkmate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessMove)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessMove)
  return false;
#undef DO_
}

void MsgChessMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessMove)
  // optional uint64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->id(), output);
  }

  // optional uint32 Source_X = 2;
  if (has_source_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->source_x(), output);
  }

  // optional uint32 Source_Y = 3;
  if (has_source_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->source_y(), output);
  }

  // optional uint32 Target_X = 4;
  if (has_target_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->target_x(), output);
  }

  // optional uint32 Target_Y = 5;
  if (has_target_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->target_y(), output);
  }

  // optional bool is_kill = 6;
  if (has_is_kill()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_kill(), output);
  }

  // optional bool is_checkmate = 7;
  if (has_is_checkmate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->is_checkmate(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessMove)
}

::google::protobuf::uint8* MsgChessMove::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessMove)
  // optional uint64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->id(), target);
  }

  // optional uint32 Source_X = 2;
  if (has_source_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->source_x(), target);
  }

  // optional uint32 Source_Y = 3;
  if (has_source_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->source_y(), target);
  }

  // optional uint32 Target_X = 4;
  if (has_target_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->target_x(), target);
  }

  // optional uint32 Target_Y = 5;
  if (has_target_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->target_y(), target);
  }

  // optional bool is_kill = 6;
  if (has_is_kill()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->is_kill(), target);
  }

  // optional bool is_checkmate = 7;
  if (has_is_checkmate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->is_checkmate(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessMove)
  return target;
}

int MsgChessMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->id());
    }

    // optional uint32 Source_X = 2;
    if (has_source_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_x());
    }

    // optional uint32 Source_Y = 3;
    if (has_source_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_y());
    }

    // optional uint32 Target_X = 4;
    if (has_target_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_x());
    }

    // optional uint32 Target_Y = 5;
    if (has_target_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_y());
    }

    // optional bool is_kill = 6;
    if (has_is_kill()) {
      total_size += 1 + 1;
    }

    // optional bool is_checkmate = 7;
    if (has_is_checkmate()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessMove::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessMove* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessMove*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessMove::MergeFrom(const MsgChessMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_source_x()) {
      set_source_x(from.source_x());
    }
    if (from.has_source_y()) {
      set_source_y(from.source_y());
    }
    if (from.has_target_x()) {
      set_target_x(from.target_x());
    }
    if (from.has_target_y()) {
      set_target_y(from.target_y());
    }
    if (from.has_is_kill()) {
      set_is_kill(from.is_kill());
    }
    if (from.has_is_checkmate()) {
      set_is_checkmate(from.is_checkmate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessMove::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessMove::CopyFrom(const MsgChessMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessMove::IsInitialized() const {

  return true;
}

void MsgChessMove::Swap(MsgChessMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(source_x_, other->source_x_);
    std::swap(source_y_, other->source_y_);
    std::swap(target_x_, other->target_x_);
    std::swap(target_y_, other->target_y_);
    std::swap(is_kill_, other->is_kill_);
    std::swap(is_checkmate_, other->is_checkmate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessMove::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessMove_descriptor_;
  metadata.reflection = MsgChessMove_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessAction::kActionIdFieldNumber;
const int MsgChessAction::kActionWikFieldNumber;
const int MsgChessAction::kRegretCountFieldNumber;
const int MsgChessAction::kLastChessFieldNumber;
const int MsgChessAction::kPlayerListFieldNumber;
#endif  // !_MSC_VER

MsgChessAction::MsgChessAction()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessAction)
}

void MsgChessAction::InitAsDefaultInstance() {
  last_chess_ = const_cast< ::MsgChessChessManual*>(&::MsgChessChessManual::default_instance());
}

MsgChessAction::MsgChessAction(const MsgChessAction& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessAction)
}

void MsgChessAction::SharedCtor() {
  _cached_size_ = 0;
  action_id_ = GOOGLE_ULONGLONG(0);
  action_wik_ = 0u;
  regret_count_ = 0u;
  last_chess_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessAction::~MsgChessAction() {
  // @@protoc_insertion_point(destructor:MsgChessAction)
  SharedDtor();
}

void MsgChessAction::SharedDtor() {
  if (this != default_instance_) {
    delete last_chess_;
  }
}

void MsgChessAction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessAction::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessAction_descriptor_;
}

const MsgChessAction& MsgChessAction::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessAction* MsgChessAction::default_instance_ = NULL;

MsgChessAction* MsgChessAction::New() const {
  return new MsgChessAction;
}

void MsgChessAction::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessAction*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(action_id_, regret_count_);
    if (has_last_chess()) {
      if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  player_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessAction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessAction)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 action_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &action_id_)));
          set_has_action_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_action_wik;
        break;
      }

      // optional uint32 action_wik = 2;
      case 2: {
        if (tag == 16) {
         parse_action_wik:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &action_wik_)));
          set_has_action_wik();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_regret_count;
        break;
      }

      // optional uint32 regret_count = 3;
      case 3: {
        if (tag == 24) {
         parse_regret_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &regret_count_)));
          set_has_regret_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_last_chess;
        break;
      }

      // optional .MsgChessChessManual last_chess = 4;
      case 4: {
        if (tag == 34) {
         parse_last_chess:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_last_chess()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_player_list;
        break;
      }

      // repeated .MsgChessPlayer player_list = 5;
      case 5: {
        if (tag == 42) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_player_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessAction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessAction)
  return false;
#undef DO_
}

void MsgChessAction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessAction)
  // optional uint64 action_id = 1;
  if (has_action_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->action_id(), output);
  }

  // optional uint32 action_wik = 2;
  if (has_action_wik()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->action_wik(), output);
  }

  // optional uint32 regret_count = 3;
  if (has_regret_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->regret_count(), output);
  }

  // optional .MsgChessChessManual last_chess = 4;
  if (has_last_chess()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->last_chess(), output);
  }

  // repeated .MsgChessPlayer player_list = 5;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->player_list(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessAction)
}

::google::protobuf::uint8* MsgChessAction::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessAction)
  // optional uint64 action_id = 1;
  if (has_action_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->action_id(), target);
  }

  // optional uint32 action_wik = 2;
  if (has_action_wik()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->action_wik(), target);
  }

  // optional uint32 regret_count = 3;
  if (has_regret_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->regret_count(), target);
  }

  // optional .MsgChessChessManual last_chess = 4;
  if (has_last_chess()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->last_chess(), target);
  }

  // repeated .MsgChessPlayer player_list = 5;
  for (int i = 0; i < this->player_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->player_list(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessAction)
  return target;
}

int MsgChessAction::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 action_id = 1;
    if (has_action_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->action_id());
    }

    // optional uint32 action_wik = 2;
    if (has_action_wik()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->action_wik());
    }

    // optional uint32 regret_count = 3;
    if (has_regret_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->regret_count());
    }

    // optional .MsgChessChessManual last_chess = 4;
    if (has_last_chess()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->last_chess());
    }

  }
  // repeated .MsgChessPlayer player_list = 5;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessAction::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessAction* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessAction*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessAction::MergeFrom(const MsgChessAction& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_action_id()) {
      set_action_id(from.action_id());
    }
    if (from.has_action_wik()) {
      set_action_wik(from.action_wik());
    }
    if (from.has_regret_count()) {
      set_regret_count(from.regret_count());
    }
    if (from.has_last_chess()) {
      mutable_last_chess()->::MsgChessChessManual::MergeFrom(from.last_chess());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessAction::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessAction::CopyFrom(const MsgChessAction& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessAction::IsInitialized() const {

  return true;
}

void MsgChessAction::Swap(MsgChessAction* other) {
  if (other != this) {
    std::swap(action_id_, other->action_id_);
    std::swap(action_wik_, other->action_wik_);
    std::swap(regret_count_, other->regret_count_);
    std::swap(last_chess_, other->last_chess_);
    player_list_.Swap(&other->player_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessAction::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessAction_descriptor_;
  metadata.reflection = MsgChessAction_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessChessManual::kTargetXFieldNumber;
const int MsgChessChessManual::kTargetYFieldNumber;
const int MsgChessChessManual::kSourceXFieldNumber;
const int MsgChessChessManual::kSourceYFieldNumber;
const int MsgChessChessManual::kSourceIdFieldNumber;
const int MsgChessChessManual::kColorFieldNumber;
const int MsgChessChessManual::kChessTypeFieldNumber;
const int MsgChessChessManual::kChessTargetFieldNumber;
const int MsgChessChessManual::kTargetIdFieldNumber;
#endif  // !_MSC_VER

MsgChessChessManual::MsgChessChessManual()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessChessManual)
}

void MsgChessChessManual::InitAsDefaultInstance() {
}

MsgChessChessManual::MsgChessChessManual(const MsgChessChessManual& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessChessManual)
}

void MsgChessChessManual::SharedCtor() {
  _cached_size_ = 0;
  target_x_ = 0u;
  target_y_ = 0u;
  source_x_ = 0u;
  source_y_ = 0u;
  source_id_ = 0u;
  color_ = 0;
  chess_type_ = 0;
  chess_target_ = 0;
  target_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessChessManual::~MsgChessChessManual() {
  // @@protoc_insertion_point(destructor:MsgChessChessManual)
  SharedDtor();
}

void MsgChessChessManual::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgChessChessManual::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessChessManual::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessChessManual_descriptor_;
}

const MsgChessChessManual& MsgChessChessManual::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessChessManual* MsgChessChessManual::default_instance_ = NULL;

MsgChessChessManual* MsgChessChessManual::New() const {
  return new MsgChessChessManual;
}

void MsgChessChessManual::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessChessManual*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(target_x_, chess_target_);
  }
  target_id_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessChessManual::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessChessManual)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 target_x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_x_)));
          set_has_target_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_target_y;
        break;
      }

      // optional uint32 target_y = 2;
      case 2: {
        if (tag == 16) {
         parse_target_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_y_)));
          set_has_target_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_source_x;
        break;
      }

      // optional uint32 source_x = 3;
      case 3: {
        if (tag == 24) {
         parse_source_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_x_)));
          set_has_source_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_source_y;
        break;
      }

      // optional uint32 source_y = 4;
      case 4: {
        if (tag == 32) {
         parse_source_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_y_)));
          set_has_source_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_source_id;
        break;
      }

      // optional uint32 source_id = 5;
      case 5: {
        if (tag == 40) {
         parse_source_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_id_)));
          set_has_source_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_color;
        break;
      }

      // optional .TChessColor color = 6;
      case 6: {
        if (tag == 48) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessColor_IsValid(value)) {
            set_color(static_cast< ::TChessColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_chess_type;
        break;
      }

      // optional .TChessType chess_type = 7;
      case 7: {
        if (tag == 56) {
         parse_chess_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessType_IsValid(value)) {
            set_chess_type(static_cast< ::TChessType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_chess_target;
        break;
      }

      // optional .TChessType chess_target = 8;
      case 8: {
        if (tag == 64) {
         parse_chess_target:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessType_IsValid(value)) {
            set_chess_target(static_cast< ::TChessType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_target_id;
        break;
      }

      // optional uint32 target_id = 9;
      case 9: {
        if (tag == 72) {
         parse_target_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_id_)));
          set_has_target_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessChessManual)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessChessManual)
  return false;
#undef DO_
}

void MsgChessChessManual::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessChessManual)
  // optional uint32 target_x = 1;
  if (has_target_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_x(), output);
  }

  // optional uint32 target_y = 2;
  if (has_target_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_y(), output);
  }

  // optional uint32 source_x = 3;
  if (has_source_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->source_x(), output);
  }

  // optional uint32 source_y = 4;
  if (has_source_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->source_y(), output);
  }

  // optional uint32 source_id = 5;
  if (has_source_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->source_id(), output);
  }

  // optional .TChessColor color = 6;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->color(), output);
  }

  // optional .TChessType chess_type = 7;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->chess_type(), output);
  }

  // optional .TChessType chess_target = 8;
  if (has_chess_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->chess_target(), output);
  }

  // optional uint32 target_id = 9;
  if (has_target_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->target_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessChessManual)
}

::google::protobuf::uint8* MsgChessChessManual::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessChessManual)
  // optional uint32 target_x = 1;
  if (has_target_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->target_x(), target);
  }

  // optional uint32 target_y = 2;
  if (has_target_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->target_y(), target);
  }

  // optional uint32 source_x = 3;
  if (has_source_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->source_x(), target);
  }

  // optional uint32 source_y = 4;
  if (has_source_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->source_y(), target);
  }

  // optional uint32 source_id = 5;
  if (has_source_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->source_id(), target);
  }

  // optional .TChessColor color = 6;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->color(), target);
  }

  // optional .TChessType chess_type = 7;
  if (has_chess_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->chess_type(), target);
  }

  // optional .TChessType chess_target = 8;
  if (has_chess_target()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->chess_target(), target);
  }

  // optional uint32 target_id = 9;
  if (has_target_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->target_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessChessManual)
  return target;
}

int MsgChessChessManual::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 target_x = 1;
    if (has_target_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_x());
    }

    // optional uint32 target_y = 2;
    if (has_target_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_y());
    }

    // optional uint32 source_x = 3;
    if (has_source_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_x());
    }

    // optional uint32 source_y = 4;
    if (has_source_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_y());
    }

    // optional uint32 source_id = 5;
    if (has_source_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_id());
    }

    // optional .TChessColor color = 6;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

    // optional .TChessType chess_type = 7;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->chess_type());
    }

    // optional .TChessType chess_target = 8;
    if (has_chess_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->chess_target());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 target_id = 9;
    if (has_target_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessChessManual::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessChessManual* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessChessManual*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessChessManual::MergeFrom(const MsgChessChessManual& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_x()) {
      set_target_x(from.target_x());
    }
    if (from.has_target_y()) {
      set_target_y(from.target_y());
    }
    if (from.has_source_x()) {
      set_source_x(from.source_x());
    }
    if (from.has_source_y()) {
      set_source_y(from.source_y());
    }
    if (from.has_source_id()) {
      set_source_id(from.source_id());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
    if (from.has_chess_target()) {
      set_chess_target(from.chess_target());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_target_id()) {
      set_target_id(from.target_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessChessManual::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessChessManual::CopyFrom(const MsgChessChessManual& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessChessManual::IsInitialized() const {

  return true;
}

void MsgChessChessManual::Swap(MsgChessChessManual* other) {
  if (other != this) {
    std::swap(target_x_, other->target_x_);
    std::swap(target_y_, other->target_y_);
    std::swap(source_x_, other->source_x_);
    std::swap(source_y_, other->source_y_);
    std::swap(source_id_, other->source_id_);
    std::swap(color_, other->color_);
    std::swap(chess_type_, other->chess_type_);
    std::swap(chess_target_, other->chess_target_);
    std::swap(target_id_, other->target_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessChessManual::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessChessManual_descriptor_;
  metadata.reflection = MsgChessChessManual_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessItemInfo::kPositionXFieldNumber;
const int MsgChessItemInfo::kPositionYFieldNumber;
const int MsgChessItemInfo::kChessTypeFieldNumber;
const int MsgChessItemInfo::kShowchessFieldNumber;
#endif  // !_MSC_VER

MsgChessItemInfo::MsgChessItemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessItemInfo)
}

void MsgChessItemInfo::InitAsDefaultInstance() {
}

MsgChessItemInfo::MsgChessItemInfo(const MsgChessItemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessItemInfo)
}

void MsgChessItemInfo::SharedCtor() {
  _cached_size_ = 0;
  position_x_ = 0u;
  position_y_ = 0u;
  chess_type_ = 0;
  showchess_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessItemInfo::~MsgChessItemInfo() {
  // @@protoc_insertion_point(destructor:MsgChessItemInfo)
  SharedDtor();
}

void MsgChessItemInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgChessItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessItemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessItemInfo_descriptor_;
}

const MsgChessItemInfo& MsgChessItemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessItemInfo* MsgChessItemInfo::default_instance_ = NULL;

MsgChessItemInfo* MsgChessItemInfo::New() const {
  return new MsgChessItemInfo;
}

void MsgChessItemInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessItemInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(position_x_, showchess_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessItemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 position_x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &position_x_)));
          set_has_position_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_position_y;
        break;
      }

      // optional uint32 position_y = 2;
      case 2: {
        if (tag == 16) {
         parse_position_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &position_y_)));
          set_has_position_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_chess_type;
        break;
      }

      // optional .TChessType chess_type = 3;
      case 3: {
        if (tag == 24) {
         parse_chess_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessType_IsValid(value)) {
            set_chess_type(static_cast< ::TChessType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_showchess;
        break;
      }

      // optional .TChessShow showchess = 4;
      case 4: {
        if (tag == 32) {
         parse_showchess:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessShow_IsValid(value)) {
            set_showchess(static_cast< ::TChessShow >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessItemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessItemInfo)
  return false;
#undef DO_
}

void MsgChessItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessItemInfo)
  // optional uint32 position_x = 1;
  if (has_position_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->position_x(), output);
  }

  // optional uint32 position_y = 2;
  if (has_position_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->position_y(), output);
  }

  // optional .TChessType chess_type = 3;
  if (has_chess_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->chess_type(), output);
  }

  // optional .TChessShow showchess = 4;
  if (has_showchess()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->showchess(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessItemInfo)
}

::google::protobuf::uint8* MsgChessItemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessItemInfo)
  // optional uint32 position_x = 1;
  if (has_position_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->position_x(), target);
  }

  // optional uint32 position_y = 2;
  if (has_position_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->position_y(), target);
  }

  // optional .TChessType chess_type = 3;
  if (has_chess_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->chess_type(), target);
  }

  // optional .TChessShow showchess = 4;
  if (has_showchess()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->showchess(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessItemInfo)
  return target;
}

int MsgChessItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 position_x = 1;
    if (has_position_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->position_x());
    }

    // optional uint32 position_y = 2;
    if (has_position_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->position_y());
    }

    // optional .TChessType chess_type = 3;
    if (has_chess_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->chess_type());
    }

    // optional .TChessShow showchess = 4;
    if (has_showchess()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->showchess());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessItemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessItemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessItemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessItemInfo::MergeFrom(const MsgChessItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position_x()) {
      set_position_x(from.position_x());
    }
    if (from.has_position_y()) {
      set_position_y(from.position_y());
    }
    if (from.has_chess_type()) {
      set_chess_type(from.chess_type());
    }
    if (from.has_showchess()) {
      set_showchess(from.showchess());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessItemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessItemInfo::CopyFrom(const MsgChessItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessItemInfo::IsInitialized() const {

  return true;
}

void MsgChessItemInfo::Swap(MsgChessItemInfo* other) {
  if (other != this) {
    std::swap(position_x_, other->position_x_);
    std::swap(position_y_, other->position_y_);
    std::swap(chess_type_, other->chess_type_);
    std::swap(showchess_, other->showchess_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessItemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessItemInfo_descriptor_;
  metadata.reflection = MsgChessItemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessRoom::kRoomStateFieldNumber;
const int MsgChessRoom::kStateTimeFieldNumber;
const int MsgChessRoom::kPlayerListFieldNumber;
const int MsgChessRoom::kRoomIdFieldNumber;
const int MsgChessRoom::kGameCountFieldNumber;
const int MsgChessRoom::kPrivateRoomFieldNumber;
const int MsgChessRoom::kRoleHostFieldNumber;
const int MsgChessRoom::kRoleStateFieldNumber;
const int MsgChessRoom::kRelieveFieldNumber;
const int MsgChessRoom::kRoomPayTypeFieldNumber;
const int MsgChessRoom::kActionIdFieldNumber;
const int MsgChessRoom::kWikiFieldNumber;
const int MsgChessRoom::kLastChessFieldNumber;
#endif  // !_MSC_VER

MsgChessRoom::MsgChessRoom()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessRoom)
}

void MsgChessRoom::InitAsDefaultInstance() {
  private_room_ = const_cast< ::MsgCreatePrivateRoom*>(&::MsgCreatePrivateRoom::default_instance());
  role_host_ = const_cast< ::MsgRoleHostCount*>(&::MsgRoleHostCount::default_instance());
  role_state_ = const_cast< ::MsgRoleStateCount*>(&::MsgRoleStateCount::default_instance());
  last_chess_ = const_cast< ::MsgChessChessManual*>(&::MsgChessChessManual::default_instance());
}

MsgChessRoom::MsgChessRoom(const MsgChessRoom& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessRoom)
}

void MsgChessRoom::SharedCtor() {
  _cached_size_ = 0;
  room_state_ = 0;
  state_time_ = 0u;
  room_id_ = GOOGLE_ULONGLONG(0);
  game_count_ = 0u;
  private_room_ = NULL;
  role_host_ = NULL;
  role_state_ = NULL;
  relieve_ = false;
  room_pay_type_ = 0u;
  action_id_ = GOOGLE_ULONGLONG(0);
  wiki_ = 0u;
  last_chess_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessRoom::~MsgChessRoom() {
  // @@protoc_insertion_point(destructor:MsgChessRoom)
  SharedDtor();
}

void MsgChessRoom::SharedDtor() {
  if (this != default_instance_) {
    delete private_room_;
    delete role_host_;
    delete role_state_;
    delete last_chess_;
  }
}

void MsgChessRoom::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessRoom::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessRoom_descriptor_;
}

const MsgChessRoom& MsgChessRoom::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessRoom* MsgChessRoom::default_instance_ = NULL;

MsgChessRoom* MsgChessRoom::New() const {
  return new MsgChessRoom;
}

void MsgChessRoom::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessRoom*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 251) {
    ZR_(room_state_, state_time_);
    room_id_ = GOOGLE_ULONGLONG(0);
    game_count_ = 0u;
    if (has_private_room()) {
      if (private_room_ != NULL) private_room_->::MsgCreatePrivateRoom::Clear();
    }
    if (has_role_host()) {
      if (role_host_ != NULL) role_host_->::MsgRoleHostCount::Clear();
    }
    if (has_role_state()) {
      if (role_state_ != NULL) role_state_->::MsgRoleStateCount::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 7936) {
    ZR_(action_id_, wiki_);
    relieve_ = false;
    if (has_last_chess()) {
      if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  player_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessRoom::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessRoom)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TChessState room_state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessState_IsValid(value)) {
            set_room_state(static_cast< ::TChessState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state_time;
        break;
      }

      // optional uint32 state_time = 2;
      case 2: {
        if (tag == 16) {
         parse_state_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_time_)));
          set_has_state_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_list;
        break;
      }

      // repeated .MsgChessPlayer player_list = 3;
      case 3: {
        if (tag == 26) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_list;
        if (input->ExpectTag(32)) goto parse_room_id;
        break;
      }

      // optional uint64 room_id = 4;
      case 4: {
        if (tag == 32) {
         parse_room_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &room_id_)));
          set_has_room_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_game_count;
        break;
      }

      // optional uint32 game_count = 5;
      case 5: {
        if (tag == 40) {
         parse_game_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &game_count_)));
          set_has_game_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_private_room;
        break;
      }

      // optional .MsgCreatePrivateRoom private_room = 6;
      case 6: {
        if (tag == 50) {
         parse_private_room:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_private_room()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_role_host;
        break;
      }

      // optional .MsgRoleHostCount role_host = 7;
      case 7: {
        if (tag == 58) {
         parse_role_host:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_role_host()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_role_state;
        break;
      }

      // optional .MsgRoleStateCount role_state = 8;
      case 8: {
        if (tag == 66) {
         parse_role_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_role_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_relieve;
        break;
      }

      // optional bool relieve = 9;
      case 9: {
        if (tag == 72) {
         parse_relieve:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &relieve_)));
          set_has_relieve();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_room_pay_type;
        break;
      }

      // optional uint32 room_pay_type = 10;
      case 10: {
        if (tag == 80) {
         parse_room_pay_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &room_pay_type_)));
          set_has_room_pay_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_action_id;
        break;
      }

      // optional uint64 action_id = 11;
      case 11: {
        if (tag == 88) {
         parse_action_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &action_id_)));
          set_has_action_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_wiki;
        break;
      }

      // optional uint32 wiki = 12;
      case 12: {
        if (tag == 96) {
         parse_wiki:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &wiki_)));
          set_has_wiki();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_last_chess;
        break;
      }

      // optional .MsgChessChessManual last_chess = 13;
      case 13: {
        if (tag == 106) {
         parse_last_chess:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_last_chess()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessRoom)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessRoom)
  return false;
#undef DO_
}

void MsgChessRoom::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessRoom)
  // optional .TChessState room_state = 1;
  if (has_room_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->room_state(), output);
  }

  // optional uint32 state_time = 2;
  if (has_state_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state_time(), output);
  }

  // repeated .MsgChessPlayer player_list = 3;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->player_list(i), output);
  }

  // optional uint64 room_id = 4;
  if (has_room_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->room_id(), output);
  }

  // optional uint32 game_count = 5;
  if (has_game_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->game_count(), output);
  }

  // optional .MsgCreatePrivateRoom private_room = 6;
  if (has_private_room()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->private_room(), output);
  }

  // optional .MsgRoleHostCount role_host = 7;
  if (has_role_host()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->role_host(), output);
  }

  // optional .MsgRoleStateCount role_state = 8;
  if (has_role_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->role_state(), output);
  }

  // optional bool relieve = 9;
  if (has_relieve()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->relieve(), output);
  }

  // optional uint32 room_pay_type = 10;
  if (has_room_pay_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->room_pay_type(), output);
  }

  // optional uint64 action_id = 11;
  if (has_action_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->action_id(), output);
  }

  // optional uint32 wiki = 12;
  if (has_wiki()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->wiki(), output);
  }

  // optional .MsgChessChessManual last_chess = 13;
  if (has_last_chess()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->last_chess(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessRoom)
}

::google::protobuf::uint8* MsgChessRoom::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessRoom)
  // optional .TChessState room_state = 1;
  if (has_room_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->room_state(), target);
  }

  // optional uint32 state_time = 2;
  if (has_state_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->state_time(), target);
  }

  // repeated .MsgChessPlayer player_list = 3;
  for (int i = 0; i < this->player_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->player_list(i), target);
  }

  // optional uint64 room_id = 4;
  if (has_room_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->room_id(), target);
  }

  // optional uint32 game_count = 5;
  if (has_game_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->game_count(), target);
  }

  // optional .MsgCreatePrivateRoom private_room = 6;
  if (has_private_room()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->private_room(), target);
  }

  // optional .MsgRoleHostCount role_host = 7;
  if (has_role_host()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->role_host(), target);
  }

  // optional .MsgRoleStateCount role_state = 8;
  if (has_role_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->role_state(), target);
  }

  // optional bool relieve = 9;
  if (has_relieve()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->relieve(), target);
  }

  // optional uint32 room_pay_type = 10;
  if (has_room_pay_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->room_pay_type(), target);
  }

  // optional uint64 action_id = 11;
  if (has_action_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->action_id(), target);
  }

  // optional uint32 wiki = 12;
  if (has_wiki()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->wiki(), target);
  }

  // optional .MsgChessChessManual last_chess = 13;
  if (has_last_chess()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->last_chess(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessRoom)
  return target;
}

int MsgChessRoom::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TChessState room_state = 1;
    if (has_room_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->room_state());
    }

    // optional uint32 state_time = 2;
    if (has_state_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state_time());
    }

    // optional uint64 room_id = 4;
    if (has_room_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->room_id());
    }

    // optional uint32 game_count = 5;
    if (has_game_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->game_count());
    }

    // optional .MsgCreatePrivateRoom private_room = 6;
    if (has_private_room()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->private_room());
    }

    // optional .MsgRoleHostCount role_host = 7;
    if (has_role_host()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->role_host());
    }

    // optional .MsgRoleStateCount role_state = 8;
    if (has_role_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->role_state());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool relieve = 9;
    if (has_relieve()) {
      total_size += 1 + 1;
    }

    // optional uint32 room_pay_type = 10;
    if (has_room_pay_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->room_pay_type());
    }

    // optional uint64 action_id = 11;
    if (has_action_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->action_id());
    }

    // optional uint32 wiki = 12;
    if (has_wiki()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->wiki());
    }

    // optional .MsgChessChessManual last_chess = 13;
    if (has_last_chess()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->last_chess());
    }

  }
  // repeated .MsgChessPlayer player_list = 3;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessRoom::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessRoom* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessRoom*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessRoom::MergeFrom(const MsgChessRoom& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_state()) {
      set_room_state(from.room_state());
    }
    if (from.has_state_time()) {
      set_state_time(from.state_time());
    }
    if (from.has_room_id()) {
      set_room_id(from.room_id());
    }
    if (from.has_game_count()) {
      set_game_count(from.game_count());
    }
    if (from.has_private_room()) {
      mutable_private_room()->::MsgCreatePrivateRoom::MergeFrom(from.private_room());
    }
    if (from.has_role_host()) {
      mutable_role_host()->::MsgRoleHostCount::MergeFrom(from.role_host());
    }
    if (from.has_role_state()) {
      mutable_role_state()->::MsgRoleStateCount::MergeFrom(from.role_state());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_relieve()) {
      set_relieve(from.relieve());
    }
    if (from.has_room_pay_type()) {
      set_room_pay_type(from.room_pay_type());
    }
    if (from.has_action_id()) {
      set_action_id(from.action_id());
    }
    if (from.has_wiki()) {
      set_wiki(from.wiki());
    }
    if (from.has_last_chess()) {
      mutable_last_chess()->::MsgChessChessManual::MergeFrom(from.last_chess());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessRoom::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessRoom::CopyFrom(const MsgChessRoom& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessRoom::IsInitialized() const {

  return true;
}

void MsgChessRoom::Swap(MsgChessRoom* other) {
  if (other != this) {
    std::swap(room_state_, other->room_state_);
    std::swap(state_time_, other->state_time_);
    player_list_.Swap(&other->player_list_);
    std::swap(room_id_, other->room_id_);
    std::swap(game_count_, other->game_count_);
    std::swap(private_room_, other->private_room_);
    std::swap(role_host_, other->role_host_);
    std::swap(role_state_, other->role_state_);
    std::swap(relieve_, other->relieve_);
    std::swap(room_pay_type_, other->room_pay_type_);
    std::swap(action_id_, other->action_id_);
    std::swap(wiki_, other->wiki_);
    std::swap(last_chess_, other->last_chess_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessRoom::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessRoom_descriptor_;
  metadata.reflection = MsgChessRoom_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessGameOverInfo::kWinCountFieldNumber;
const int MsgChessGameOverInfo::kLoseCountFieldNumber;
const int MsgChessGameOverInfo::kPeaceCountFieldNumber;
#endif  // !_MSC_VER

MsgChessGameOverInfo::MsgChessGameOverInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessGameOverInfo)
}

void MsgChessGameOverInfo::InitAsDefaultInstance() {
}

MsgChessGameOverInfo::MsgChessGameOverInfo(const MsgChessGameOverInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessGameOverInfo)
}

void MsgChessGameOverInfo::SharedCtor() {
  _cached_size_ = 0;
  win_count_ = 0u;
  lose_count_ = 0u;
  peace_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessGameOverInfo::~MsgChessGameOverInfo() {
  // @@protoc_insertion_point(destructor:MsgChessGameOverInfo)
  SharedDtor();
}

void MsgChessGameOverInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgChessGameOverInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessGameOverInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessGameOverInfo_descriptor_;
}

const MsgChessGameOverInfo& MsgChessGameOverInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessGameOverInfo* MsgChessGameOverInfo::default_instance_ = NULL;

MsgChessGameOverInfo* MsgChessGameOverInfo::New() const {
  return new MsgChessGameOverInfo;
}

void MsgChessGameOverInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessGameOverInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(win_count_, peace_count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessGameOverInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessGameOverInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 win_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &win_count_)));
          set_has_win_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_lose_count;
        break;
      }

      // optional uint32 lose_count = 2;
      case 2: {
        if (tag == 16) {
         parse_lose_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lose_count_)));
          set_has_lose_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_peace_count;
        break;
      }

      // optional uint32 peace_count = 3;
      case 3: {
        if (tag == 24) {
         parse_peace_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peace_count_)));
          set_has_peace_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessGameOverInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessGameOverInfo)
  return false;
#undef DO_
}

void MsgChessGameOverInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessGameOverInfo)
  // optional uint32 win_count = 1;
  if (has_win_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->win_count(), output);
  }

  // optional uint32 lose_count = 2;
  if (has_lose_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->lose_count(), output);
  }

  // optional uint32 peace_count = 3;
  if (has_peace_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->peace_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessGameOverInfo)
}

::google::protobuf::uint8* MsgChessGameOverInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessGameOverInfo)
  // optional uint32 win_count = 1;
  if (has_win_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->win_count(), target);
  }

  // optional uint32 lose_count = 2;
  if (has_lose_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->lose_count(), target);
  }

  // optional uint32 peace_count = 3;
  if (has_peace_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->peace_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessGameOverInfo)
  return target;
}

int MsgChessGameOverInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 win_count = 1;
    if (has_win_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->win_count());
    }

    // optional uint32 lose_count = 2;
    if (has_lose_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lose_count());
    }

    // optional uint32 peace_count = 3;
    if (has_peace_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peace_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessGameOverInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessGameOverInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessGameOverInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessGameOverInfo::MergeFrom(const MsgChessGameOverInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_win_count()) {
      set_win_count(from.win_count());
    }
    if (from.has_lose_count()) {
      set_lose_count(from.lose_count());
    }
    if (from.has_peace_count()) {
      set_peace_count(from.peace_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessGameOverInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessGameOverInfo::CopyFrom(const MsgChessGameOverInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessGameOverInfo::IsInitialized() const {

  return true;
}

void MsgChessGameOverInfo::Swap(MsgChessGameOverInfo* other) {
  if (other != this) {
    std::swap(win_count_, other->win_count_);
    std::swap(lose_count_, other->lose_count_);
    std::swap(peace_count_, other->peace_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessGameOverInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessGameOverInfo_descriptor_;
  metadata.reflection = MsgChessGameOverInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessShowDown::kRoomStateFieldNumber;
const int MsgChessShowDown::kStateTimeFieldNumber;
const int MsgChessShowDown::kPlayerListFieldNumber;
const int MsgChessShowDown::kRoomIdFieldNumber;
const int MsgChessShowDown::kWinIdFieldNumber;
const int MsgChessShowDown::kGameCountFieldNumber;
const int MsgChessShowDown::kTimeFieldNumber;
const int MsgChessShowDown::kGameOverFieldNumber;
const int MsgChessShowDown::kIntegralListFieldNumber;
const int MsgChessShowDown::kLastChessFieldNumber;
#endif  // !_MSC_VER

MsgChessShowDown::MsgChessShowDown()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessShowDown)
}

void MsgChessShowDown::InitAsDefaultInstance() {
  last_chess_ = const_cast< ::MsgChessChessManual*>(&::MsgChessChessManual::default_instance());
}

MsgChessShowDown::MsgChessShowDown(const MsgChessShowDown& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessShowDown)
}

void MsgChessShowDown::SharedCtor() {
  _cached_size_ = 0;
  room_state_ = 0;
  state_time_ = 0u;
  room_id_ = GOOGLE_ULONGLONG(0);
  win_id_ = GOOGLE_ULONGLONG(0);
  game_count_ = 0u;
  time_ = 0u;
  game_over_ = false;
  last_chess_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessShowDown::~MsgChessShowDown() {
  // @@protoc_insertion_point(destructor:MsgChessShowDown)
  SharedDtor();
}

void MsgChessShowDown::SharedDtor() {
  if (this != default_instance_) {
    delete last_chess_;
  }
}

void MsgChessShowDown::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessShowDown::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessShowDown_descriptor_;
}

const MsgChessShowDown& MsgChessShowDown::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessShowDown* MsgChessShowDown::default_instance_ = NULL;

MsgChessShowDown* MsgChessShowDown::New() const {
  return new MsgChessShowDown;
}

void MsgChessShowDown::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessShowDown*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 251) {
    ZR_(room_state_, state_time_);
    ZR_(room_id_, time_);
    game_over_ = false;
  }
  if (has_last_chess()) {
    if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  player_list_.Clear();
  integral_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessShowDown::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessShowDown)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TChessState room_state = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::TChessState_IsValid(value)) {
            set_room_state(static_cast< ::TChessState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state_time;
        break;
      }

      // optional uint32 state_time = 2;
      case 2: {
        if (tag == 16) {
         parse_state_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &state_time_)));
          set_has_state_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_list;
        break;
      }

      // repeated .MsgChessPlayer player_list = 3;
      case 3: {
        if (tag == 26) {
         parse_player_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_player_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_player_list;
        if (input->ExpectTag(32)) goto parse_room_id;
        break;
      }

      // optional uint64 room_id = 4;
      case 4: {
        if (tag == 32) {
         parse_room_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &room_id_)));
          set_has_room_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_win_id;
        break;
      }

      // optional uint64 win_id = 5;
      case 5: {
        if (tag == 40) {
         parse_win_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &win_id_)));
          set_has_win_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_game_count;
        break;
      }

      // optional uint32 game_count = 6;
      case 6: {
        if (tag == 48) {
         parse_game_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &game_count_)));
          set_has_game_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_time;
        break;
      }

      // optional uint32 time = 7;
      case 7: {
        if (tag == 56) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_game_over;
        break;
      }

      // optional bool game_over = 8;
      case 8: {
        if (tag == 64) {
         parse_game_over:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &game_over_)));
          set_has_game_over();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_integral_list;
        break;
      }

      // repeated .MsgChessIntegralCount integral_list = 9;
      case 9: {
        if (tag == 74) {
         parse_integral_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_integral_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_integral_list;
        if (input->ExpectTag(82)) goto parse_last_chess;
        break;
      }

      // optional .MsgChessChessManual last_chess = 10;
      case 10: {
        if (tag == 82) {
         parse_last_chess:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_last_chess()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessShowDown)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessShowDown)
  return false;
#undef DO_
}

void MsgChessShowDown::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessShowDown)
  // optional .TChessState room_state = 1;
  if (has_room_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->room_state(), output);
  }

  // optional uint32 state_time = 2;
  if (has_state_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->state_time(), output);
  }

  // repeated .MsgChessPlayer player_list = 3;
  for (int i = 0; i < this->player_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->player_list(i), output);
  }

  // optional uint64 room_id = 4;
  if (has_room_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->room_id(), output);
  }

  // optional uint64 win_id = 5;
  if (has_win_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->win_id(), output);
  }

  // optional uint32 game_count = 6;
  if (has_game_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->game_count(), output);
  }

  // optional uint32 time = 7;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->time(), output);
  }

  // optional bool game_over = 8;
  if (has_game_over()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->game_over(), output);
  }

  // repeated .MsgChessIntegralCount integral_list = 9;
  for (int i = 0; i < this->integral_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->integral_list(i), output);
  }

  // optional .MsgChessChessManual last_chess = 10;
  if (has_last_chess()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->last_chess(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessShowDown)
}

::google::protobuf::uint8* MsgChessShowDown::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessShowDown)
  // optional .TChessState room_state = 1;
  if (has_room_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->room_state(), target);
  }

  // optional uint32 state_time = 2;
  if (has_state_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->state_time(), target);
  }

  // repeated .MsgChessPlayer player_list = 3;
  for (int i = 0; i < this->player_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->player_list(i), target);
  }

  // optional uint64 room_id = 4;
  if (has_room_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->room_id(), target);
  }

  // optional uint64 win_id = 5;
  if (has_win_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->win_id(), target);
  }

  // optional uint32 game_count = 6;
  if (has_game_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->game_count(), target);
  }

  // optional uint32 time = 7;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->time(), target);
  }

  // optional bool game_over = 8;
  if (has_game_over()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->game_over(), target);
  }

  // repeated .MsgChessIntegralCount integral_list = 9;
  for (int i = 0; i < this->integral_list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->integral_list(i), target);
  }

  // optional .MsgChessChessManual last_chess = 10;
  if (has_last_chess()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->last_chess(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessShowDown)
  return target;
}

int MsgChessShowDown::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TChessState room_state = 1;
    if (has_room_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->room_state());
    }

    // optional uint32 state_time = 2;
    if (has_state_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->state_time());
    }

    // optional uint64 room_id = 4;
    if (has_room_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->room_id());
    }

    // optional uint64 win_id = 5;
    if (has_win_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->win_id());
    }

    // optional uint32 game_count = 6;
    if (has_game_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->game_count());
    }

    // optional uint32 time = 7;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional bool game_over = 8;
    if (has_game_over()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional .MsgChessChessManual last_chess = 10;
    if (has_last_chess()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->last_chess());
    }

  }
  // repeated .MsgChessPlayer player_list = 3;
  total_size += 1 * this->player_list_size();
  for (int i = 0; i < this->player_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->player_list(i));
  }

  // repeated .MsgChessIntegralCount integral_list = 9;
  total_size += 1 * this->integral_list_size();
  for (int i = 0; i < this->integral_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->integral_list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessShowDown::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessShowDown* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessShowDown*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessShowDown::MergeFrom(const MsgChessShowDown& from) {
  GOOGLE_CHECK_NE(&from, this);
  player_list_.MergeFrom(from.player_list_);
  integral_list_.MergeFrom(from.integral_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_room_state()) {
      set_room_state(from.room_state());
    }
    if (from.has_state_time()) {
      set_state_time(from.state_time());
    }
    if (from.has_room_id()) {
      set_room_id(from.room_id());
    }
    if (from.has_win_id()) {
      set_win_id(from.win_id());
    }
    if (from.has_game_count()) {
      set_game_count(from.game_count());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_game_over()) {
      set_game_over(from.game_over());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_last_chess()) {
      mutable_last_chess()->::MsgChessChessManual::MergeFrom(from.last_chess());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessShowDown::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessShowDown::CopyFrom(const MsgChessShowDown& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessShowDown::IsInitialized() const {

  return true;
}

void MsgChessShowDown::Swap(MsgChessShowDown* other) {
  if (other != this) {
    std::swap(room_state_, other->room_state_);
    std::swap(state_time_, other->state_time_);
    player_list_.Swap(&other->player_list_);
    std::swap(room_id_, other->room_id_);
    std::swap(win_id_, other->win_id_);
    std::swap(game_count_, other->game_count_);
    std::swap(time_, other->time_);
    std::swap(game_over_, other->game_over_);
    integral_list_.Swap(&other->integral_list_);
    std::swap(last_chess_, other->last_chess_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessShowDown::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessShowDown_descriptor_;
  metadata.reflection = MsgChessShowDown_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MsgChessIntegralCount::kRoleidFieldNumber;
const int MsgChessIntegralCount::kCountFieldNumber;
#endif  // !_MSC_VER

MsgChessIntegralCount::MsgChessIntegralCount()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MsgChessIntegralCount)
}

void MsgChessIntegralCount::InitAsDefaultInstance() {
}

MsgChessIntegralCount::MsgChessIntegralCount(const MsgChessIntegralCount& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MsgChessIntegralCount)
}

void MsgChessIntegralCount::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_ULONGLONG(0);
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgChessIntegralCount::~MsgChessIntegralCount() {
  // @@protoc_insertion_point(destructor:MsgChessIntegralCount)
  SharedDtor();
}

void MsgChessIntegralCount::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MsgChessIntegralCount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MsgChessIntegralCount::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MsgChessIntegralCount_descriptor_;
}

const MsgChessIntegralCount& MsgChessIntegralCount::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_msg_5fchess_2eproto();
  return *default_instance_;
}

MsgChessIntegralCount* MsgChessIntegralCount::default_instance_ = NULL;

MsgChessIntegralCount* MsgChessIntegralCount::New() const {
  return new MsgChessIntegralCount;
}

void MsgChessIntegralCount::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgChessIntegralCount*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(roleid_, count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MsgChessIntegralCount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MsgChessIntegralCount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 roleid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional uint32 count = 2;
      case 2: {
        if (tag == 16) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MsgChessIntegralCount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MsgChessIntegralCount)
  return false;
#undef DO_
}

void MsgChessIntegralCount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MsgChessIntegralCount)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->roleid(), output);
  }

  // optional uint32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MsgChessIntegralCount)
}

::google::protobuf::uint8* MsgChessIntegralCount::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MsgChessIntegralCount)
  // optional uint64 roleid = 1;
  if (has_roleid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->roleid(), target);
  }

  // optional uint32 count = 2;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MsgChessIntegralCount)
  return target;
}

int MsgChessIntegralCount::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 roleid = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->roleid());
    }

    // optional uint32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgChessIntegralCount::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MsgChessIntegralCount* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MsgChessIntegralCount*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MsgChessIntegralCount::MergeFrom(const MsgChessIntegralCount& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MsgChessIntegralCount::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MsgChessIntegralCount::CopyFrom(const MsgChessIntegralCount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgChessIntegralCount::IsInitialized() const {

  return true;
}

void MsgChessIntegralCount::Swap(MsgChessIntegralCount* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MsgChessIntegralCount::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MsgChessIntegralCount_descriptor_;
  metadata.reflection = MsgChessIntegralCount_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
