// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_chess.proto

#ifndef PROTOBUF_msg_5fchess_2eproto__INCLUDED
#define PROTOBUF_msg_5fchess_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "public_pro.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_msg_5fchess_2eproto();
void protobuf_AssignDesc_msg_5fchess_2eproto();
void protobuf_ShutdownFile_msg_5fchess_2eproto();

class MsgChessPlayer;
class MsgChessMove;
class MsgChessAction;
class MsgChessChessManual;
class MsgChessItemInfo;
class MsgChessRoom;
class MsgChessGameOverInfo;
class MsgChessShowDown;
class MsgChessIntegralCount;

enum TChessState {
  TChessStateWait = 0,
  TChessStateCheckStartGame = 1,
  TChessStateStartGame = 2,
  TChessStateAction = 3,
  TChessStateAskPeace = 4,
  TChessStateAskUndoAction = 5,
  TChessStateShowDown = 6,
  TChessStateRelieveRoom = 7
};
bool TChessState_IsValid(int value);
const TChessState TChessState_MIN = TChessStateWait;
const TChessState TChessState_MAX = TChessStateRelieveRoom;
const int TChessState_ARRAYSIZE = TChessState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessState_descriptor();
inline const ::std::string& TChessState_Name(TChessState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessState_descriptor(), value);
}
inline bool TChessState_Parse(
    const ::std::string& name, TChessState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessState>(
    TChessState_descriptor(), name, value);
}
enum TChessPlayerState {
  STATE_CS_READY = 1,
  STATE_CS_NEWROLE = 2,
  STATE_CS_ROOM_OWNER = 4,
  STATE_CS_RELIEVE = 8,
  STATE_CS_LEAVE = 16,
  STATE_CS_LIMIT = 32,
  STATE_CS_OFFLINE = 64,
  STATE_CS_CONTINUE_GAME = 128
};
bool TChessPlayerState_IsValid(int value);
const TChessPlayerState TChessPlayerState_MIN = STATE_CS_READY;
const TChessPlayerState TChessPlayerState_MAX = STATE_CS_CONTINUE_GAME;
const int TChessPlayerState_ARRAYSIZE = TChessPlayerState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessPlayerState_descriptor();
inline const ::std::string& TChessPlayerState_Name(TChessPlayerState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessPlayerState_descriptor(), value);
}
inline bool TChessPlayerState_Parse(
    const ::std::string& name, TChessPlayerState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessPlayerState>(
    TChessPlayerState_descriptor(), name, value);
}
enum TChessPlayerWik {
  CS_WIK_NULL = 1,
  CS_WIK_ASKPEACE = 2,
  CS_WIK_UNDOACTION = 4,
  CS_WIK_ASKLOSE = 8
};
bool TChessPlayerWik_IsValid(int value);
const TChessPlayerWik TChessPlayerWik_MIN = CS_WIK_NULL;
const TChessPlayerWik TChessPlayerWik_MAX = CS_WIK_ASKLOSE;
const int TChessPlayerWik_ARRAYSIZE = TChessPlayerWik_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessPlayerWik_descriptor();
inline const ::std::string& TChessPlayerWik_Name(TChessPlayerWik value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessPlayerWik_descriptor(), value);
}
inline bool TChessPlayerWik_Parse(
    const ::std::string& name, TChessPlayerWik* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessPlayerWik>(
    TChessPlayerWik_descriptor(), name, value);
}
enum TChessType {
  CHESS_TYPE_NULL = 0,
  CHESS_GENERAL = 1,
  CHESS_KAVASS = 2,
  CHESS_ELEPHANT = 3,
  CHESS_HORSE = 4,
  CHESS_ROOK = 5,
  CHESS_CANNON = 6,
  CHESS_SOLDIER = 7
};
bool TChessType_IsValid(int value);
const TChessType TChessType_MIN = CHESS_TYPE_NULL;
const TChessType TChessType_MAX = CHESS_SOLDIER;
const int TChessType_ARRAYSIZE = TChessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessType_descriptor();
inline const ::std::string& TChessType_Name(TChessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessType_descriptor(), value);
}
inline bool TChessType_Parse(
    const ::std::string& name, TChessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessType>(
    TChessType_descriptor(), name, value);
}
enum TChessColor {
  CHESS_NULL = 0,
  CHESS_BLACK = 1,
  CHESS_RED = 2
};
bool TChessColor_IsValid(int value);
const TChessColor TChessColor_MIN = CHESS_NULL;
const TChessColor TChessColor_MAX = CHESS_RED;
const int TChessColor_ARRAYSIZE = TChessColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessColor_descriptor();
inline const ::std::string& TChessColor_Name(TChessColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessColor_descriptor(), value);
}
inline bool TChessColor_Parse(
    const ::std::string& name, TChessColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessColor>(
    TChessColor_descriptor(), name, value);
}
enum TChessShow {
  CHESS_SHOW_NULL = 0,
  CHESS_SHOW_OPEN = 1,
  CHESS_SHOW_CLOSE = 2
};
bool TChessShow_IsValid(int value);
const TChessShow TChessShow_MIN = CHESS_SHOW_NULL;
const TChessShow TChessShow_MAX = CHESS_SHOW_CLOSE;
const int TChessShow_ARRAYSIZE = TChessShow_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessShow_descriptor();
inline const ::std::string& TChessShow_Name(TChessShow value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessShow_descriptor(), value);
}
inline bool TChessShow_Parse(
    const ::std::string& name, TChessShow* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessShow>(
    TChessShow_descriptor(), name, value);
}
enum TChessStepState {
  CHESS_STEP_NULL = 0,
  CHESS_STEP_CHECK = 1,
  CHESS_STEP_CATCH = 2,
  CHESS_STEP_EAT = 3
};
bool TChessStepState_IsValid(int value);
const TChessStepState TChessStepState_MIN = CHESS_STEP_NULL;
const TChessStepState TChessStepState_MAX = CHESS_STEP_EAT;
const int TChessStepState_ARRAYSIZE = TChessStepState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TChessStepState_descriptor();
inline const ::std::string& TChessStepState_Name(TChessStepState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TChessStepState_descriptor(), value);
}
inline bool TChessStepState_Parse(
    const ::std::string& name, TChessStepState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TChessStepState>(
    TChessStepState_descriptor(), name, value);
}
// ===================================================================

class MsgChessPlayer : public ::google::protobuf::Message {
 public:
  MsgChessPlayer();
  virtual ~MsgChessPlayer();

  MsgChessPlayer(const MsgChessPlayer& from);

  inline MsgChessPlayer& operator=(const MsgChessPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessPlayer& default_instance();

  void Swap(MsgChessPlayer* other);

  // implements Message ----------------------------------------------

  MsgChessPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessPlayer& from);
  void MergeFrom(const MsgChessPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MsgPlayerInfo player_base = 1;
  inline bool has_player_base() const;
  inline void clear_player_base();
  static const int kPlayerBaseFieldNumber = 1;
  inline const ::MsgPlayerInfo& player_base() const;
  inline ::MsgPlayerInfo* mutable_player_base();
  inline ::MsgPlayerInfo* release_player_base();
  inline void set_allocated_player_base(::MsgPlayerInfo* player_base);

  // optional uint32 seats = 2;
  inline bool has_seats() const;
  inline void clear_seats();
  static const int kSeatsFieldNumber = 2;
  inline ::google::protobuf::uint32 seats() const;
  inline void set_seats(::google::protobuf::uint32 value);

  // optional int64 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int64 score() const;
  inline void set_score(::google::protobuf::int64 value);

  // optional .MsgChessGameOverInfo overInfo = 4;
  inline bool has_overinfo() const;
  inline void clear_overinfo();
  static const int kOverInfoFieldNumber = 4;
  inline const ::MsgChessGameOverInfo& overinfo() const;
  inline ::MsgChessGameOverInfo* mutable_overinfo();
  inline ::MsgChessGameOverInfo* release_overinfo();
  inline void set_allocated_overinfo(::MsgChessGameOverInfo* overinfo);

  // optional .TChessColor color = 5;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 5;
  inline ::TChessColor color() const;
  inline void set_color(::TChessColor value);

  // optional uint32 regret_count = 6;
  inline bool has_regret_count() const;
  inline void clear_regret_count();
  static const int kRegretCountFieldNumber = 6;
  inline ::google::protobuf::uint32 regret_count() const;
  inline void set_regret_count(::google::protobuf::uint32 value);

  // repeated .MsgChessItemInfo chess_item = 7;
  inline int chess_item_size() const;
  inline void clear_chess_item();
  static const int kChessItemFieldNumber = 7;
  inline const ::MsgChessItemInfo& chess_item(int index) const;
  inline ::MsgChessItemInfo* mutable_chess_item(int index);
  inline ::MsgChessItemInfo* add_chess_item();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgChessItemInfo >&
      chess_item() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgChessItemInfo >*
      mutable_chess_item();

  // optional uint32 state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // repeated .TChessType eatchess_list = 9;
  inline int eatchess_list_size() const;
  inline void clear_eatchess_list();
  static const int kEatchessListFieldNumber = 9;
  inline ::TChessType eatchess_list(int index) const;
  inline void set_eatchess_list(int index, ::TChessType value);
  inline void add_eatchess_list(::TChessType value);
  inline const ::google::protobuf::RepeatedField<int>& eatchess_list() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_eatchess_list();

  // optional uint32 innings_time = 10;
  inline bool has_innings_time() const;
  inline void clear_innings_time();
  static const int kInningsTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 innings_time() const;
  inline void set_innings_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgChessPlayer)
 private:
  inline void set_has_player_base();
  inline void clear_has_player_base();
  inline void set_has_seats();
  inline void clear_has_seats();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_overinfo();
  inline void clear_has_overinfo();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_regret_count();
  inline void clear_has_regret_count();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_innings_time();
  inline void clear_has_innings_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MsgPlayerInfo* player_base_;
  ::google::protobuf::int64 score_;
  ::google::protobuf::uint32 seats_;
  int color_;
  ::MsgChessGameOverInfo* overinfo_;
  ::google::protobuf::RepeatedPtrField< ::MsgChessItemInfo > chess_item_;
  ::google::protobuf::uint32 regret_count_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::RepeatedField<int> eatchess_list_;
  ::google::protobuf::uint32 innings_time_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessPlayer* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessMove : public ::google::protobuf::Message {
 public:
  MsgChessMove();
  virtual ~MsgChessMove();

  MsgChessMove(const MsgChessMove& from);

  inline MsgChessMove& operator=(const MsgChessMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessMove& default_instance();

  void Swap(MsgChessMove* other);

  // implements Message ----------------------------------------------

  MsgChessMove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessMove& from);
  void MergeFrom(const MsgChessMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional uint32 Source_X = 2;
  inline bool has_source_x() const;
  inline void clear_source_x();
  static const int kSourceXFieldNumber = 2;
  inline ::google::protobuf::uint32 source_x() const;
  inline void set_source_x(::google::protobuf::uint32 value);

  // optional uint32 Source_Y = 3;
  inline bool has_source_y() const;
  inline void clear_source_y();
  static const int kSourceYFieldNumber = 3;
  inline ::google::protobuf::uint32 source_y() const;
  inline void set_source_y(::google::protobuf::uint32 value);

  // optional uint32 Target_X = 4;
  inline bool has_target_x() const;
  inline void clear_target_x();
  static const int kTargetXFieldNumber = 4;
  inline ::google::protobuf::uint32 target_x() const;
  inline void set_target_x(::google::protobuf::uint32 value);

  // optional uint32 Target_Y = 5;
  inline bool has_target_y() const;
  inline void clear_target_y();
  static const int kTargetYFieldNumber = 5;
  inline ::google::protobuf::uint32 target_y() const;
  inline void set_target_y(::google::protobuf::uint32 value);

  // optional bool is_kill = 6;
  inline bool has_is_kill() const;
  inline void clear_is_kill();
  static const int kIsKillFieldNumber = 6;
  inline bool is_kill() const;
  inline void set_is_kill(bool value);

  // optional bool is_checkmate = 7;
  inline bool has_is_checkmate() const;
  inline void clear_is_checkmate();
  static const int kIsCheckmateFieldNumber = 7;
  inline bool is_checkmate() const;
  inline void set_is_checkmate(bool value);

  // @@protoc_insertion_point(class_scope:MsgChessMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_source_x();
  inline void clear_has_source_x();
  inline void set_has_source_y();
  inline void clear_has_source_y();
  inline void set_has_target_x();
  inline void clear_has_target_x();
  inline void set_has_target_y();
  inline void clear_has_target_y();
  inline void set_has_is_kill();
  inline void clear_has_is_kill();
  inline void set_has_is_checkmate();
  inline void clear_has_is_checkmate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint32 source_x_;
  ::google::protobuf::uint32 source_y_;
  ::google::protobuf::uint32 target_x_;
  ::google::protobuf::uint32 target_y_;
  bool is_kill_;
  bool is_checkmate_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessMove* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessAction : public ::google::protobuf::Message {
 public:
  MsgChessAction();
  virtual ~MsgChessAction();

  MsgChessAction(const MsgChessAction& from);

  inline MsgChessAction& operator=(const MsgChessAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessAction& default_instance();

  void Swap(MsgChessAction* other);

  // implements Message ----------------------------------------------

  MsgChessAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessAction& from);
  void MergeFrom(const MsgChessAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 action_id = 1;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 action_id() const;
  inline void set_action_id(::google::protobuf::uint64 value);

  // optional uint32 action_wik = 2;
  inline bool has_action_wik() const;
  inline void clear_action_wik();
  static const int kActionWikFieldNumber = 2;
  inline ::google::protobuf::uint32 action_wik() const;
  inline void set_action_wik(::google::protobuf::uint32 value);

  // optional uint32 regret_count = 3;
  inline bool has_regret_count() const;
  inline void clear_regret_count();
  static const int kRegretCountFieldNumber = 3;
  inline ::google::protobuf::uint32 regret_count() const;
  inline void set_regret_count(::google::protobuf::uint32 value);

  // optional .MsgChessChessManual last_chess = 4;
  inline bool has_last_chess() const;
  inline void clear_last_chess();
  static const int kLastChessFieldNumber = 4;
  inline const ::MsgChessChessManual& last_chess() const;
  inline ::MsgChessChessManual* mutable_last_chess();
  inline ::MsgChessChessManual* release_last_chess();
  inline void set_allocated_last_chess(::MsgChessChessManual* last_chess);

  // repeated .MsgChessPlayer player_list = 5;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 5;
  inline const ::MsgChessPlayer& player_list(int index) const;
  inline ::MsgChessPlayer* mutable_player_list(int index);
  inline ::MsgChessPlayer* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
      mutable_player_list();

  // @@protoc_insertion_point(class_scope:MsgChessAction)
 private:
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_action_wik();
  inline void clear_has_action_wik();
  inline void set_has_regret_count();
  inline void clear_has_regret_count();
  inline void set_has_last_chess();
  inline void clear_has_last_chess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 action_id_;
  ::google::protobuf::uint32 action_wik_;
  ::google::protobuf::uint32 regret_count_;
  ::MsgChessChessManual* last_chess_;
  ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer > player_list_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessAction* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessChessManual : public ::google::protobuf::Message {
 public:
  MsgChessChessManual();
  virtual ~MsgChessChessManual();

  MsgChessChessManual(const MsgChessChessManual& from);

  inline MsgChessChessManual& operator=(const MsgChessChessManual& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessChessManual& default_instance();

  void Swap(MsgChessChessManual* other);

  // implements Message ----------------------------------------------

  MsgChessChessManual* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessChessManual& from);
  void MergeFrom(const MsgChessChessManual& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 target_x = 1;
  inline bool has_target_x() const;
  inline void clear_target_x();
  static const int kTargetXFieldNumber = 1;
  inline ::google::protobuf::uint32 target_x() const;
  inline void set_target_x(::google::protobuf::uint32 value);

  // optional uint32 target_y = 2;
  inline bool has_target_y() const;
  inline void clear_target_y();
  static const int kTargetYFieldNumber = 2;
  inline ::google::protobuf::uint32 target_y() const;
  inline void set_target_y(::google::protobuf::uint32 value);

  // optional uint32 source_x = 3;
  inline bool has_source_x() const;
  inline void clear_source_x();
  static const int kSourceXFieldNumber = 3;
  inline ::google::protobuf::uint32 source_x() const;
  inline void set_source_x(::google::protobuf::uint32 value);

  // optional uint32 source_y = 4;
  inline bool has_source_y() const;
  inline void clear_source_y();
  static const int kSourceYFieldNumber = 4;
  inline ::google::protobuf::uint32 source_y() const;
  inline void set_source_y(::google::protobuf::uint32 value);

  // optional uint32 source_id = 5;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 5;
  inline ::google::protobuf::uint32 source_id() const;
  inline void set_source_id(::google::protobuf::uint32 value);

  // optional .TChessColor color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline ::TChessColor color() const;
  inline void set_color(::TChessColor value);

  // optional .TChessType chess_type = 7;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 7;
  inline ::TChessType chess_type() const;
  inline void set_chess_type(::TChessType value);

  // optional .TChessType chess_target = 8;
  inline bool has_chess_target() const;
  inline void clear_chess_target();
  static const int kChessTargetFieldNumber = 8;
  inline ::TChessType chess_target() const;
  inline void set_chess_target(::TChessType value);

  // optional uint32 target_id = 9;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 9;
  inline ::google::protobuf::uint32 target_id() const;
  inline void set_target_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgChessChessManual)
 private:
  inline void set_has_target_x();
  inline void clear_has_target_x();
  inline void set_has_target_y();
  inline void clear_has_target_y();
  inline void set_has_source_x();
  inline void clear_has_source_x();
  inline void set_has_source_y();
  inline void clear_has_source_y();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_chess_type();
  inline void clear_has_chess_type();
  inline void set_has_chess_target();
  inline void clear_has_chess_target();
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 target_x_;
  ::google::protobuf::uint32 target_y_;
  ::google::protobuf::uint32 source_x_;
  ::google::protobuf::uint32 source_y_;
  ::google::protobuf::uint32 source_id_;
  int color_;
  int chess_type_;
  int chess_target_;
  ::google::protobuf::uint32 target_id_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessChessManual* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessItemInfo : public ::google::protobuf::Message {
 public:
  MsgChessItemInfo();
  virtual ~MsgChessItemInfo();

  MsgChessItemInfo(const MsgChessItemInfo& from);

  inline MsgChessItemInfo& operator=(const MsgChessItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessItemInfo& default_instance();

  void Swap(MsgChessItemInfo* other);

  // implements Message ----------------------------------------------

  MsgChessItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessItemInfo& from);
  void MergeFrom(const MsgChessItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 position_x = 1;
  inline bool has_position_x() const;
  inline void clear_position_x();
  static const int kPositionXFieldNumber = 1;
  inline ::google::protobuf::uint32 position_x() const;
  inline void set_position_x(::google::protobuf::uint32 value);

  // optional uint32 position_y = 2;
  inline bool has_position_y() const;
  inline void clear_position_y();
  static const int kPositionYFieldNumber = 2;
  inline ::google::protobuf::uint32 position_y() const;
  inline void set_position_y(::google::protobuf::uint32 value);

  // optional .TChessType chess_type = 3;
  inline bool has_chess_type() const;
  inline void clear_chess_type();
  static const int kChessTypeFieldNumber = 3;
  inline ::TChessType chess_type() const;
  inline void set_chess_type(::TChessType value);

  // optional .TChessShow showchess = 4;
  inline bool has_showchess() const;
  inline void clear_showchess();
  static const int kShowchessFieldNumber = 4;
  inline ::TChessShow showchess() const;
  inline void set_showchess(::TChessShow value);

  // @@protoc_insertion_point(class_scope:MsgChessItemInfo)
 private:
  inline void set_has_position_x();
  inline void clear_has_position_x();
  inline void set_has_position_y();
  inline void clear_has_position_y();
  inline void set_has_chess_type();
  inline void clear_has_chess_type();
  inline void set_has_showchess();
  inline void clear_has_showchess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 position_x_;
  ::google::protobuf::uint32 position_y_;
  int chess_type_;
  int showchess_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessRoom : public ::google::protobuf::Message {
 public:
  MsgChessRoom();
  virtual ~MsgChessRoom();

  MsgChessRoom(const MsgChessRoom& from);

  inline MsgChessRoom& operator=(const MsgChessRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessRoom& default_instance();

  void Swap(MsgChessRoom* other);

  // implements Message ----------------------------------------------

  MsgChessRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessRoom& from);
  void MergeFrom(const MsgChessRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TChessState room_state = 1;
  inline bool has_room_state() const;
  inline void clear_room_state();
  static const int kRoomStateFieldNumber = 1;
  inline ::TChessState room_state() const;
  inline void set_room_state(::TChessState value);

  // optional uint32 state_time = 2;
  inline bool has_state_time() const;
  inline void clear_state_time();
  static const int kStateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 state_time() const;
  inline void set_state_time(::google::protobuf::uint32 value);

  // repeated .MsgChessPlayer player_list = 3;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 3;
  inline const ::MsgChessPlayer& player_list(int index) const;
  inline ::MsgChessPlayer* mutable_player_list(int index);
  inline ::MsgChessPlayer* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
      mutable_player_list();

  // optional uint64 room_id = 4;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::uint64 room_id() const;
  inline void set_room_id(::google::protobuf::uint64 value);

  // optional uint32 game_count = 5;
  inline bool has_game_count() const;
  inline void clear_game_count();
  static const int kGameCountFieldNumber = 5;
  inline ::google::protobuf::uint32 game_count() const;
  inline void set_game_count(::google::protobuf::uint32 value);

  // optional .MsgCreatePrivateRoom private_room = 6;
  inline bool has_private_room() const;
  inline void clear_private_room();
  static const int kPrivateRoomFieldNumber = 6;
  inline const ::MsgCreatePrivateRoom& private_room() const;
  inline ::MsgCreatePrivateRoom* mutable_private_room();
  inline ::MsgCreatePrivateRoom* release_private_room();
  inline void set_allocated_private_room(::MsgCreatePrivateRoom* private_room);

  // optional .MsgRoleHostCount role_host = 7;
  inline bool has_role_host() const;
  inline void clear_role_host();
  static const int kRoleHostFieldNumber = 7;
  inline const ::MsgRoleHostCount& role_host() const;
  inline ::MsgRoleHostCount* mutable_role_host();
  inline ::MsgRoleHostCount* release_role_host();
  inline void set_allocated_role_host(::MsgRoleHostCount* role_host);

  // optional .MsgRoleStateCount role_state = 8;
  inline bool has_role_state() const;
  inline void clear_role_state();
  static const int kRoleStateFieldNumber = 8;
  inline const ::MsgRoleStateCount& role_state() const;
  inline ::MsgRoleStateCount* mutable_role_state();
  inline ::MsgRoleStateCount* release_role_state();
  inline void set_allocated_role_state(::MsgRoleStateCount* role_state);

  // optional bool relieve = 9;
  inline bool has_relieve() const;
  inline void clear_relieve();
  static const int kRelieveFieldNumber = 9;
  inline bool relieve() const;
  inline void set_relieve(bool value);

  // optional uint32 room_pay_type = 10;
  inline bool has_room_pay_type() const;
  inline void clear_room_pay_type();
  static const int kRoomPayTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 room_pay_type() const;
  inline void set_room_pay_type(::google::protobuf::uint32 value);

  // optional uint64 action_id = 11;
  inline bool has_action_id() const;
  inline void clear_action_id();
  static const int kActionIdFieldNumber = 11;
  inline ::google::protobuf::uint64 action_id() const;
  inline void set_action_id(::google::protobuf::uint64 value);

  // optional uint32 wiki = 12;
  inline bool has_wiki() const;
  inline void clear_wiki();
  static const int kWikiFieldNumber = 12;
  inline ::google::protobuf::uint32 wiki() const;
  inline void set_wiki(::google::protobuf::uint32 value);

  // optional .MsgChessChessManual last_chess = 13;
  inline bool has_last_chess() const;
  inline void clear_last_chess();
  static const int kLastChessFieldNumber = 13;
  inline const ::MsgChessChessManual& last_chess() const;
  inline ::MsgChessChessManual* mutable_last_chess();
  inline ::MsgChessChessManual* release_last_chess();
  inline void set_allocated_last_chess(::MsgChessChessManual* last_chess);

  // @@protoc_insertion_point(class_scope:MsgChessRoom)
 private:
  inline void set_has_room_state();
  inline void clear_has_room_state();
  inline void set_has_state_time();
  inline void clear_has_state_time();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_game_count();
  inline void clear_has_game_count();
  inline void set_has_private_room();
  inline void clear_has_private_room();
  inline void set_has_role_host();
  inline void clear_has_role_host();
  inline void set_has_role_state();
  inline void clear_has_role_state();
  inline void set_has_relieve();
  inline void clear_has_relieve();
  inline void set_has_room_pay_type();
  inline void clear_has_room_pay_type();
  inline void set_has_action_id();
  inline void clear_has_action_id();
  inline void set_has_wiki();
  inline void clear_has_wiki();
  inline void set_has_last_chess();
  inline void clear_has_last_chess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int room_state_;
  ::google::protobuf::uint32 state_time_;
  ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer > player_list_;
  ::google::protobuf::uint64 room_id_;
  ::MsgCreatePrivateRoom* private_room_;
  ::MsgRoleHostCount* role_host_;
  ::google::protobuf::uint32 game_count_;
  bool relieve_;
  ::MsgRoleStateCount* role_state_;
  ::google::protobuf::uint64 action_id_;
  ::google::protobuf::uint32 room_pay_type_;
  ::google::protobuf::uint32 wiki_;
  ::MsgChessChessManual* last_chess_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessRoom* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessGameOverInfo : public ::google::protobuf::Message {
 public:
  MsgChessGameOverInfo();
  virtual ~MsgChessGameOverInfo();

  MsgChessGameOverInfo(const MsgChessGameOverInfo& from);

  inline MsgChessGameOverInfo& operator=(const MsgChessGameOverInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessGameOverInfo& default_instance();

  void Swap(MsgChessGameOverInfo* other);

  // implements Message ----------------------------------------------

  MsgChessGameOverInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessGameOverInfo& from);
  void MergeFrom(const MsgChessGameOverInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 win_count = 1;
  inline bool has_win_count() const;
  inline void clear_win_count();
  static const int kWinCountFieldNumber = 1;
  inline ::google::protobuf::uint32 win_count() const;
  inline void set_win_count(::google::protobuf::uint32 value);

  // optional uint32 lose_count = 2;
  inline bool has_lose_count() const;
  inline void clear_lose_count();
  static const int kLoseCountFieldNumber = 2;
  inline ::google::protobuf::uint32 lose_count() const;
  inline void set_lose_count(::google::protobuf::uint32 value);

  // optional uint32 peace_count = 3;
  inline bool has_peace_count() const;
  inline void clear_peace_count();
  static const int kPeaceCountFieldNumber = 3;
  inline ::google::protobuf::uint32 peace_count() const;
  inline void set_peace_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgChessGameOverInfo)
 private:
  inline void set_has_win_count();
  inline void clear_has_win_count();
  inline void set_has_lose_count();
  inline void clear_has_lose_count();
  inline void set_has_peace_count();
  inline void clear_has_peace_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 win_count_;
  ::google::protobuf::uint32 lose_count_;
  ::google::protobuf::uint32 peace_count_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessGameOverInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessShowDown : public ::google::protobuf::Message {
 public:
  MsgChessShowDown();
  virtual ~MsgChessShowDown();

  MsgChessShowDown(const MsgChessShowDown& from);

  inline MsgChessShowDown& operator=(const MsgChessShowDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessShowDown& default_instance();

  void Swap(MsgChessShowDown* other);

  // implements Message ----------------------------------------------

  MsgChessShowDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessShowDown& from);
  void MergeFrom(const MsgChessShowDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TChessState room_state = 1;
  inline bool has_room_state() const;
  inline void clear_room_state();
  static const int kRoomStateFieldNumber = 1;
  inline ::TChessState room_state() const;
  inline void set_room_state(::TChessState value);

  // optional uint32 state_time = 2;
  inline bool has_state_time() const;
  inline void clear_state_time();
  static const int kStateTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 state_time() const;
  inline void set_state_time(::google::protobuf::uint32 value);

  // repeated .MsgChessPlayer player_list = 3;
  inline int player_list_size() const;
  inline void clear_player_list();
  static const int kPlayerListFieldNumber = 3;
  inline const ::MsgChessPlayer& player_list(int index) const;
  inline ::MsgChessPlayer* mutable_player_list(int index);
  inline ::MsgChessPlayer* add_player_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
      player_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
      mutable_player_list();

  // optional uint64 room_id = 4;
  inline bool has_room_id() const;
  inline void clear_room_id();
  static const int kRoomIdFieldNumber = 4;
  inline ::google::protobuf::uint64 room_id() const;
  inline void set_room_id(::google::protobuf::uint64 value);

  // optional uint64 win_id = 5;
  inline bool has_win_id() const;
  inline void clear_win_id();
  static const int kWinIdFieldNumber = 5;
  inline ::google::protobuf::uint64 win_id() const;
  inline void set_win_id(::google::protobuf::uint64 value);

  // optional uint32 game_count = 6;
  inline bool has_game_count() const;
  inline void clear_game_count();
  static const int kGameCountFieldNumber = 6;
  inline ::google::protobuf::uint32 game_count() const;
  inline void set_game_count(::google::protobuf::uint32 value);

  // optional uint32 time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional bool game_over = 8;
  inline bool has_game_over() const;
  inline void clear_game_over();
  static const int kGameOverFieldNumber = 8;
  inline bool game_over() const;
  inline void set_game_over(bool value);

  // repeated .MsgChessIntegralCount integral_list = 9;
  inline int integral_list_size() const;
  inline void clear_integral_list();
  static const int kIntegralListFieldNumber = 9;
  inline const ::MsgChessIntegralCount& integral_list(int index) const;
  inline ::MsgChessIntegralCount* mutable_integral_list(int index);
  inline ::MsgChessIntegralCount* add_integral_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MsgChessIntegralCount >&
      integral_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MsgChessIntegralCount >*
      mutable_integral_list();

  // optional .MsgChessChessManual last_chess = 10;
  inline bool has_last_chess() const;
  inline void clear_last_chess();
  static const int kLastChessFieldNumber = 10;
  inline const ::MsgChessChessManual& last_chess() const;
  inline ::MsgChessChessManual* mutable_last_chess();
  inline ::MsgChessChessManual* release_last_chess();
  inline void set_allocated_last_chess(::MsgChessChessManual* last_chess);

  // @@protoc_insertion_point(class_scope:MsgChessShowDown)
 private:
  inline void set_has_room_state();
  inline void clear_has_room_state();
  inline void set_has_state_time();
  inline void clear_has_state_time();
  inline void set_has_room_id();
  inline void clear_has_room_id();
  inline void set_has_win_id();
  inline void clear_has_win_id();
  inline void set_has_game_count();
  inline void clear_has_game_count();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_game_over();
  inline void clear_has_game_over();
  inline void set_has_last_chess();
  inline void clear_has_last_chess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int room_state_;
  ::google::protobuf::uint32 state_time_;
  ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer > player_list_;
  ::google::protobuf::uint64 room_id_;
  ::google::protobuf::uint64 win_id_;
  ::google::protobuf::uint32 game_count_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::RepeatedPtrField< ::MsgChessIntegralCount > integral_list_;
  ::MsgChessChessManual* last_chess_;
  bool game_over_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessShowDown* default_instance_;
};
// -------------------------------------------------------------------

class MsgChessIntegralCount : public ::google::protobuf::Message {
 public:
  MsgChessIntegralCount();
  virtual ~MsgChessIntegralCount();

  MsgChessIntegralCount(const MsgChessIntegralCount& from);

  inline MsgChessIntegralCount& operator=(const MsgChessIntegralCount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgChessIntegralCount& default_instance();

  void Swap(MsgChessIntegralCount* other);

  // implements Message ----------------------------------------------

  MsgChessIntegralCount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgChessIntegralCount& from);
  void MergeFrom(const MsgChessIntegralCount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 roleid = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleidFieldNumber = 1;
  inline ::google::protobuf::uint64 roleid() const;
  inline void set_roleid(::google::protobuf::uint64 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MsgChessIntegralCount)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 roleid_;
  ::google::protobuf::uint32 count_;
  friend void  protobuf_AddDesc_msg_5fchess_2eproto();
  friend void protobuf_AssignDesc_msg_5fchess_2eproto();
  friend void protobuf_ShutdownFile_msg_5fchess_2eproto();

  void InitAsDefaultInstance();
  static MsgChessIntegralCount* default_instance_;
};
// ===================================================================


// ===================================================================

// MsgChessPlayer

// optional .MsgPlayerInfo player_base = 1;
inline bool MsgChessPlayer::has_player_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessPlayer::set_has_player_base() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessPlayer::clear_has_player_base() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessPlayer::clear_player_base() {
  if (player_base_ != NULL) player_base_->::MsgPlayerInfo::Clear();
  clear_has_player_base();
}
inline const ::MsgPlayerInfo& MsgChessPlayer::player_base() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.player_base)
  return player_base_ != NULL ? *player_base_ : *default_instance_->player_base_;
}
inline ::MsgPlayerInfo* MsgChessPlayer::mutable_player_base() {
  set_has_player_base();
  if (player_base_ == NULL) player_base_ = new ::MsgPlayerInfo;
  // @@protoc_insertion_point(field_mutable:MsgChessPlayer.player_base)
  return player_base_;
}
inline ::MsgPlayerInfo* MsgChessPlayer::release_player_base() {
  clear_has_player_base();
  ::MsgPlayerInfo* temp = player_base_;
  player_base_ = NULL;
  return temp;
}
inline void MsgChessPlayer::set_allocated_player_base(::MsgPlayerInfo* player_base) {
  delete player_base_;
  player_base_ = player_base;
  if (player_base) {
    set_has_player_base();
  } else {
    clear_has_player_base();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessPlayer.player_base)
}

// optional uint32 seats = 2;
inline bool MsgChessPlayer::has_seats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessPlayer::set_has_seats() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessPlayer::clear_has_seats() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessPlayer::clear_seats() {
  seats_ = 0u;
  clear_has_seats();
}
inline ::google::protobuf::uint32 MsgChessPlayer::seats() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.seats)
  return seats_;
}
inline void MsgChessPlayer::set_seats(::google::protobuf::uint32 value) {
  set_has_seats();
  seats_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.seats)
}

// optional int64 score = 3;
inline bool MsgChessPlayer::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessPlayer::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessPlayer::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessPlayer::clear_score() {
  score_ = GOOGLE_LONGLONG(0);
  clear_has_score();
}
inline ::google::protobuf::int64 MsgChessPlayer::score() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.score)
  return score_;
}
inline void MsgChessPlayer::set_score(::google::protobuf::int64 value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.score)
}

// optional .MsgChessGameOverInfo overInfo = 4;
inline bool MsgChessPlayer::has_overinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessPlayer::set_has_overinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessPlayer::clear_has_overinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessPlayer::clear_overinfo() {
  if (overinfo_ != NULL) overinfo_->::MsgChessGameOverInfo::Clear();
  clear_has_overinfo();
}
inline const ::MsgChessGameOverInfo& MsgChessPlayer::overinfo() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.overInfo)
  return overinfo_ != NULL ? *overinfo_ : *default_instance_->overinfo_;
}
inline ::MsgChessGameOverInfo* MsgChessPlayer::mutable_overinfo() {
  set_has_overinfo();
  if (overinfo_ == NULL) overinfo_ = new ::MsgChessGameOverInfo;
  // @@protoc_insertion_point(field_mutable:MsgChessPlayer.overInfo)
  return overinfo_;
}
inline ::MsgChessGameOverInfo* MsgChessPlayer::release_overinfo() {
  clear_has_overinfo();
  ::MsgChessGameOverInfo* temp = overinfo_;
  overinfo_ = NULL;
  return temp;
}
inline void MsgChessPlayer::set_allocated_overinfo(::MsgChessGameOverInfo* overinfo) {
  delete overinfo_;
  overinfo_ = overinfo;
  if (overinfo) {
    set_has_overinfo();
  } else {
    clear_has_overinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessPlayer.overInfo)
}

// optional .TChessColor color = 5;
inline bool MsgChessPlayer::has_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgChessPlayer::set_has_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgChessPlayer::clear_has_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgChessPlayer::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::TChessColor MsgChessPlayer::color() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.color)
  return static_cast< ::TChessColor >(color_);
}
inline void MsgChessPlayer::set_color(::TChessColor value) {
  assert(::TChessColor_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.color)
}

// optional uint32 regret_count = 6;
inline bool MsgChessPlayer::has_regret_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgChessPlayer::set_has_regret_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgChessPlayer::clear_has_regret_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgChessPlayer::clear_regret_count() {
  regret_count_ = 0u;
  clear_has_regret_count();
}
inline ::google::protobuf::uint32 MsgChessPlayer::regret_count() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.regret_count)
  return regret_count_;
}
inline void MsgChessPlayer::set_regret_count(::google::protobuf::uint32 value) {
  set_has_regret_count();
  regret_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.regret_count)
}

// repeated .MsgChessItemInfo chess_item = 7;
inline int MsgChessPlayer::chess_item_size() const {
  return chess_item_.size();
}
inline void MsgChessPlayer::clear_chess_item() {
  chess_item_.Clear();
}
inline const ::MsgChessItemInfo& MsgChessPlayer::chess_item(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.chess_item)
  return chess_item_.Get(index);
}
inline ::MsgChessItemInfo* MsgChessPlayer::mutable_chess_item(int index) {
  // @@protoc_insertion_point(field_mutable:MsgChessPlayer.chess_item)
  return chess_item_.Mutable(index);
}
inline ::MsgChessItemInfo* MsgChessPlayer::add_chess_item() {
  // @@protoc_insertion_point(field_add:MsgChessPlayer.chess_item)
  return chess_item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgChessItemInfo >&
MsgChessPlayer::chess_item() const {
  // @@protoc_insertion_point(field_list:MsgChessPlayer.chess_item)
  return chess_item_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgChessItemInfo >*
MsgChessPlayer::mutable_chess_item() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessPlayer.chess_item)
  return &chess_item_;
}

// optional uint32 state = 8;
inline bool MsgChessPlayer::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgChessPlayer::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgChessPlayer::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgChessPlayer::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 MsgChessPlayer::state() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.state)
  return state_;
}
inline void MsgChessPlayer::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.state)
}

// repeated .TChessType eatchess_list = 9;
inline int MsgChessPlayer::eatchess_list_size() const {
  return eatchess_list_.size();
}
inline void MsgChessPlayer::clear_eatchess_list() {
  eatchess_list_.Clear();
}
inline ::TChessType MsgChessPlayer::eatchess_list(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.eatchess_list)
  return static_cast< ::TChessType >(eatchess_list_.Get(index));
}
inline void MsgChessPlayer::set_eatchess_list(int index, ::TChessType value) {
  assert(::TChessType_IsValid(value));
  eatchess_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:MsgChessPlayer.eatchess_list)
}
inline void MsgChessPlayer::add_eatchess_list(::TChessType value) {
  assert(::TChessType_IsValid(value));
  eatchess_list_.Add(value);
  // @@protoc_insertion_point(field_add:MsgChessPlayer.eatchess_list)
}
inline const ::google::protobuf::RepeatedField<int>&
MsgChessPlayer::eatchess_list() const {
  // @@protoc_insertion_point(field_list:MsgChessPlayer.eatchess_list)
  return eatchess_list_;
}
inline ::google::protobuf::RepeatedField<int>*
MsgChessPlayer::mutable_eatchess_list() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessPlayer.eatchess_list)
  return &eatchess_list_;
}

// optional uint32 innings_time = 10;
inline bool MsgChessPlayer::has_innings_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgChessPlayer::set_has_innings_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgChessPlayer::clear_has_innings_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgChessPlayer::clear_innings_time() {
  innings_time_ = 0u;
  clear_has_innings_time();
}
inline ::google::protobuf::uint32 MsgChessPlayer::innings_time() const {
  // @@protoc_insertion_point(field_get:MsgChessPlayer.innings_time)
  return innings_time_;
}
inline void MsgChessPlayer::set_innings_time(::google::protobuf::uint32 value) {
  set_has_innings_time();
  innings_time_ = value;
  // @@protoc_insertion_point(field_set:MsgChessPlayer.innings_time)
}

// -------------------------------------------------------------------

// MsgChessMove

// optional uint64 id = 1;
inline bool MsgChessMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessMove::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 MsgChessMove::id() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.id)
  return id_;
}
inline void MsgChessMove::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.id)
}

// optional uint32 Source_X = 2;
inline bool MsgChessMove::has_source_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessMove::set_has_source_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessMove::clear_has_source_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessMove::clear_source_x() {
  source_x_ = 0u;
  clear_has_source_x();
}
inline ::google::protobuf::uint32 MsgChessMove::source_x() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.Source_X)
  return source_x_;
}
inline void MsgChessMove::set_source_x(::google::protobuf::uint32 value) {
  set_has_source_x();
  source_x_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.Source_X)
}

// optional uint32 Source_Y = 3;
inline bool MsgChessMove::has_source_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessMove::set_has_source_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessMove::clear_has_source_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessMove::clear_source_y() {
  source_y_ = 0u;
  clear_has_source_y();
}
inline ::google::protobuf::uint32 MsgChessMove::source_y() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.Source_Y)
  return source_y_;
}
inline void MsgChessMove::set_source_y(::google::protobuf::uint32 value) {
  set_has_source_y();
  source_y_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.Source_Y)
}

// optional uint32 Target_X = 4;
inline bool MsgChessMove::has_target_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessMove::set_has_target_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessMove::clear_has_target_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessMove::clear_target_x() {
  target_x_ = 0u;
  clear_has_target_x();
}
inline ::google::protobuf::uint32 MsgChessMove::target_x() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.Target_X)
  return target_x_;
}
inline void MsgChessMove::set_target_x(::google::protobuf::uint32 value) {
  set_has_target_x();
  target_x_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.Target_X)
}

// optional uint32 Target_Y = 5;
inline bool MsgChessMove::has_target_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgChessMove::set_has_target_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgChessMove::clear_has_target_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgChessMove::clear_target_y() {
  target_y_ = 0u;
  clear_has_target_y();
}
inline ::google::protobuf::uint32 MsgChessMove::target_y() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.Target_Y)
  return target_y_;
}
inline void MsgChessMove::set_target_y(::google::protobuf::uint32 value) {
  set_has_target_y();
  target_y_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.Target_Y)
}

// optional bool is_kill = 6;
inline bool MsgChessMove::has_is_kill() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgChessMove::set_has_is_kill() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgChessMove::clear_has_is_kill() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgChessMove::clear_is_kill() {
  is_kill_ = false;
  clear_has_is_kill();
}
inline bool MsgChessMove::is_kill() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.is_kill)
  return is_kill_;
}
inline void MsgChessMove::set_is_kill(bool value) {
  set_has_is_kill();
  is_kill_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.is_kill)
}

// optional bool is_checkmate = 7;
inline bool MsgChessMove::has_is_checkmate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgChessMove::set_has_is_checkmate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgChessMove::clear_has_is_checkmate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgChessMove::clear_is_checkmate() {
  is_checkmate_ = false;
  clear_has_is_checkmate();
}
inline bool MsgChessMove::is_checkmate() const {
  // @@protoc_insertion_point(field_get:MsgChessMove.is_checkmate)
  return is_checkmate_;
}
inline void MsgChessMove::set_is_checkmate(bool value) {
  set_has_is_checkmate();
  is_checkmate_ = value;
  // @@protoc_insertion_point(field_set:MsgChessMove.is_checkmate)
}

// -------------------------------------------------------------------

// MsgChessAction

// optional uint64 action_id = 1;
inline bool MsgChessAction::has_action_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessAction::set_has_action_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessAction::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessAction::clear_action_id() {
  action_id_ = GOOGLE_ULONGLONG(0);
  clear_has_action_id();
}
inline ::google::protobuf::uint64 MsgChessAction::action_id() const {
  // @@protoc_insertion_point(field_get:MsgChessAction.action_id)
  return action_id_;
}
inline void MsgChessAction::set_action_id(::google::protobuf::uint64 value) {
  set_has_action_id();
  action_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessAction.action_id)
}

// optional uint32 action_wik = 2;
inline bool MsgChessAction::has_action_wik() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessAction::set_has_action_wik() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessAction::clear_has_action_wik() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessAction::clear_action_wik() {
  action_wik_ = 0u;
  clear_has_action_wik();
}
inline ::google::protobuf::uint32 MsgChessAction::action_wik() const {
  // @@protoc_insertion_point(field_get:MsgChessAction.action_wik)
  return action_wik_;
}
inline void MsgChessAction::set_action_wik(::google::protobuf::uint32 value) {
  set_has_action_wik();
  action_wik_ = value;
  // @@protoc_insertion_point(field_set:MsgChessAction.action_wik)
}

// optional uint32 regret_count = 3;
inline bool MsgChessAction::has_regret_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessAction::set_has_regret_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessAction::clear_has_regret_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessAction::clear_regret_count() {
  regret_count_ = 0u;
  clear_has_regret_count();
}
inline ::google::protobuf::uint32 MsgChessAction::regret_count() const {
  // @@protoc_insertion_point(field_get:MsgChessAction.regret_count)
  return regret_count_;
}
inline void MsgChessAction::set_regret_count(::google::protobuf::uint32 value) {
  set_has_regret_count();
  regret_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessAction.regret_count)
}

// optional .MsgChessChessManual last_chess = 4;
inline bool MsgChessAction::has_last_chess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessAction::set_has_last_chess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessAction::clear_has_last_chess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessAction::clear_last_chess() {
  if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
  clear_has_last_chess();
}
inline const ::MsgChessChessManual& MsgChessAction::last_chess() const {
  // @@protoc_insertion_point(field_get:MsgChessAction.last_chess)
  return last_chess_ != NULL ? *last_chess_ : *default_instance_->last_chess_;
}
inline ::MsgChessChessManual* MsgChessAction::mutable_last_chess() {
  set_has_last_chess();
  if (last_chess_ == NULL) last_chess_ = new ::MsgChessChessManual;
  // @@protoc_insertion_point(field_mutable:MsgChessAction.last_chess)
  return last_chess_;
}
inline ::MsgChessChessManual* MsgChessAction::release_last_chess() {
  clear_has_last_chess();
  ::MsgChessChessManual* temp = last_chess_;
  last_chess_ = NULL;
  return temp;
}
inline void MsgChessAction::set_allocated_last_chess(::MsgChessChessManual* last_chess) {
  delete last_chess_;
  last_chess_ = last_chess;
  if (last_chess) {
    set_has_last_chess();
  } else {
    clear_has_last_chess();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessAction.last_chess)
}

// repeated .MsgChessPlayer player_list = 5;
inline int MsgChessAction::player_list_size() const {
  return player_list_.size();
}
inline void MsgChessAction::clear_player_list() {
  player_list_.Clear();
}
inline const ::MsgChessPlayer& MsgChessAction::player_list(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessAction.player_list)
  return player_list_.Get(index);
}
inline ::MsgChessPlayer* MsgChessAction::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:MsgChessAction.player_list)
  return player_list_.Mutable(index);
}
inline ::MsgChessPlayer* MsgChessAction::add_player_list() {
  // @@protoc_insertion_point(field_add:MsgChessAction.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
MsgChessAction::player_list() const {
  // @@protoc_insertion_point(field_list:MsgChessAction.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
MsgChessAction::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessAction.player_list)
  return &player_list_;
}

// -------------------------------------------------------------------

// MsgChessChessManual

// optional uint32 target_x = 1;
inline bool MsgChessChessManual::has_target_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessChessManual::set_has_target_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessChessManual::clear_has_target_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessChessManual::clear_target_x() {
  target_x_ = 0u;
  clear_has_target_x();
}
inline ::google::protobuf::uint32 MsgChessChessManual::target_x() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.target_x)
  return target_x_;
}
inline void MsgChessChessManual::set_target_x(::google::protobuf::uint32 value) {
  set_has_target_x();
  target_x_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.target_x)
}

// optional uint32 target_y = 2;
inline bool MsgChessChessManual::has_target_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessChessManual::set_has_target_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessChessManual::clear_has_target_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessChessManual::clear_target_y() {
  target_y_ = 0u;
  clear_has_target_y();
}
inline ::google::protobuf::uint32 MsgChessChessManual::target_y() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.target_y)
  return target_y_;
}
inline void MsgChessChessManual::set_target_y(::google::protobuf::uint32 value) {
  set_has_target_y();
  target_y_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.target_y)
}

// optional uint32 source_x = 3;
inline bool MsgChessChessManual::has_source_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessChessManual::set_has_source_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessChessManual::clear_has_source_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessChessManual::clear_source_x() {
  source_x_ = 0u;
  clear_has_source_x();
}
inline ::google::protobuf::uint32 MsgChessChessManual::source_x() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.source_x)
  return source_x_;
}
inline void MsgChessChessManual::set_source_x(::google::protobuf::uint32 value) {
  set_has_source_x();
  source_x_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.source_x)
}

// optional uint32 source_y = 4;
inline bool MsgChessChessManual::has_source_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessChessManual::set_has_source_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessChessManual::clear_has_source_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessChessManual::clear_source_y() {
  source_y_ = 0u;
  clear_has_source_y();
}
inline ::google::protobuf::uint32 MsgChessChessManual::source_y() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.source_y)
  return source_y_;
}
inline void MsgChessChessManual::set_source_y(::google::protobuf::uint32 value) {
  set_has_source_y();
  source_y_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.source_y)
}

// optional uint32 source_id = 5;
inline bool MsgChessChessManual::has_source_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgChessChessManual::set_has_source_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgChessChessManual::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgChessChessManual::clear_source_id() {
  source_id_ = 0u;
  clear_has_source_id();
}
inline ::google::protobuf::uint32 MsgChessChessManual::source_id() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.source_id)
  return source_id_;
}
inline void MsgChessChessManual::set_source_id(::google::protobuf::uint32 value) {
  set_has_source_id();
  source_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.source_id)
}

// optional .TChessColor color = 6;
inline bool MsgChessChessManual::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgChessChessManual::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgChessChessManual::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgChessChessManual::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::TChessColor MsgChessChessManual::color() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.color)
  return static_cast< ::TChessColor >(color_);
}
inline void MsgChessChessManual::set_color(::TChessColor value) {
  assert(::TChessColor_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.color)
}

// optional .TChessType chess_type = 7;
inline bool MsgChessChessManual::has_chess_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgChessChessManual::set_has_chess_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgChessChessManual::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgChessChessManual::clear_chess_type() {
  chess_type_ = 0;
  clear_has_chess_type();
}
inline ::TChessType MsgChessChessManual::chess_type() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.chess_type)
  return static_cast< ::TChessType >(chess_type_);
}
inline void MsgChessChessManual::set_chess_type(::TChessType value) {
  assert(::TChessType_IsValid(value));
  set_has_chess_type();
  chess_type_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.chess_type)
}

// optional .TChessType chess_target = 8;
inline bool MsgChessChessManual::has_chess_target() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgChessChessManual::set_has_chess_target() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgChessChessManual::clear_has_chess_target() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgChessChessManual::clear_chess_target() {
  chess_target_ = 0;
  clear_has_chess_target();
}
inline ::TChessType MsgChessChessManual::chess_target() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.chess_target)
  return static_cast< ::TChessType >(chess_target_);
}
inline void MsgChessChessManual::set_chess_target(::TChessType value) {
  assert(::TChessType_IsValid(value));
  set_has_chess_target();
  chess_target_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.chess_target)
}

// optional uint32 target_id = 9;
inline bool MsgChessChessManual::has_target_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgChessChessManual::set_has_target_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgChessChessManual::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgChessChessManual::clear_target_id() {
  target_id_ = 0u;
  clear_has_target_id();
}
inline ::google::protobuf::uint32 MsgChessChessManual::target_id() const {
  // @@protoc_insertion_point(field_get:MsgChessChessManual.target_id)
  return target_id_;
}
inline void MsgChessChessManual::set_target_id(::google::protobuf::uint32 value) {
  set_has_target_id();
  target_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessChessManual.target_id)
}

// -------------------------------------------------------------------

// MsgChessItemInfo

// optional uint32 position_x = 1;
inline bool MsgChessItemInfo::has_position_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessItemInfo::set_has_position_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessItemInfo::clear_has_position_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessItemInfo::clear_position_x() {
  position_x_ = 0u;
  clear_has_position_x();
}
inline ::google::protobuf::uint32 MsgChessItemInfo::position_x() const {
  // @@protoc_insertion_point(field_get:MsgChessItemInfo.position_x)
  return position_x_;
}
inline void MsgChessItemInfo::set_position_x(::google::protobuf::uint32 value) {
  set_has_position_x();
  position_x_ = value;
  // @@protoc_insertion_point(field_set:MsgChessItemInfo.position_x)
}

// optional uint32 position_y = 2;
inline bool MsgChessItemInfo::has_position_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessItemInfo::set_has_position_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessItemInfo::clear_has_position_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessItemInfo::clear_position_y() {
  position_y_ = 0u;
  clear_has_position_y();
}
inline ::google::protobuf::uint32 MsgChessItemInfo::position_y() const {
  // @@protoc_insertion_point(field_get:MsgChessItemInfo.position_y)
  return position_y_;
}
inline void MsgChessItemInfo::set_position_y(::google::protobuf::uint32 value) {
  set_has_position_y();
  position_y_ = value;
  // @@protoc_insertion_point(field_set:MsgChessItemInfo.position_y)
}

// optional .TChessType chess_type = 3;
inline bool MsgChessItemInfo::has_chess_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessItemInfo::set_has_chess_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessItemInfo::clear_has_chess_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessItemInfo::clear_chess_type() {
  chess_type_ = 0;
  clear_has_chess_type();
}
inline ::TChessType MsgChessItemInfo::chess_type() const {
  // @@protoc_insertion_point(field_get:MsgChessItemInfo.chess_type)
  return static_cast< ::TChessType >(chess_type_);
}
inline void MsgChessItemInfo::set_chess_type(::TChessType value) {
  assert(::TChessType_IsValid(value));
  set_has_chess_type();
  chess_type_ = value;
  // @@protoc_insertion_point(field_set:MsgChessItemInfo.chess_type)
}

// optional .TChessShow showchess = 4;
inline bool MsgChessItemInfo::has_showchess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessItemInfo::set_has_showchess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessItemInfo::clear_has_showchess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessItemInfo::clear_showchess() {
  showchess_ = 0;
  clear_has_showchess();
}
inline ::TChessShow MsgChessItemInfo::showchess() const {
  // @@protoc_insertion_point(field_get:MsgChessItemInfo.showchess)
  return static_cast< ::TChessShow >(showchess_);
}
inline void MsgChessItemInfo::set_showchess(::TChessShow value) {
  assert(::TChessShow_IsValid(value));
  set_has_showchess();
  showchess_ = value;
  // @@protoc_insertion_point(field_set:MsgChessItemInfo.showchess)
}

// -------------------------------------------------------------------

// MsgChessRoom

// optional .TChessState room_state = 1;
inline bool MsgChessRoom::has_room_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessRoom::set_has_room_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessRoom::clear_has_room_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessRoom::clear_room_state() {
  room_state_ = 0;
  clear_has_room_state();
}
inline ::TChessState MsgChessRoom::room_state() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.room_state)
  return static_cast< ::TChessState >(room_state_);
}
inline void MsgChessRoom::set_room_state(::TChessState value) {
  assert(::TChessState_IsValid(value));
  set_has_room_state();
  room_state_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.room_state)
}

// optional uint32 state_time = 2;
inline bool MsgChessRoom::has_state_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessRoom::set_has_state_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessRoom::clear_has_state_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessRoom::clear_state_time() {
  state_time_ = 0u;
  clear_has_state_time();
}
inline ::google::protobuf::uint32 MsgChessRoom::state_time() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.state_time)
  return state_time_;
}
inline void MsgChessRoom::set_state_time(::google::protobuf::uint32 value) {
  set_has_state_time();
  state_time_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.state_time)
}

// repeated .MsgChessPlayer player_list = 3;
inline int MsgChessRoom::player_list_size() const {
  return player_list_.size();
}
inline void MsgChessRoom::clear_player_list() {
  player_list_.Clear();
}
inline const ::MsgChessPlayer& MsgChessRoom::player_list(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.player_list)
  return player_list_.Get(index);
}
inline ::MsgChessPlayer* MsgChessRoom::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:MsgChessRoom.player_list)
  return player_list_.Mutable(index);
}
inline ::MsgChessPlayer* MsgChessRoom::add_player_list() {
  // @@protoc_insertion_point(field_add:MsgChessRoom.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
MsgChessRoom::player_list() const {
  // @@protoc_insertion_point(field_list:MsgChessRoom.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
MsgChessRoom::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessRoom.player_list)
  return &player_list_;
}

// optional uint64 room_id = 4;
inline bool MsgChessRoom::has_room_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessRoom::set_has_room_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessRoom::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessRoom::clear_room_id() {
  room_id_ = GOOGLE_ULONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::uint64 MsgChessRoom::room_id() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.room_id)
  return room_id_;
}
inline void MsgChessRoom::set_room_id(::google::protobuf::uint64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.room_id)
}

// optional uint32 game_count = 5;
inline bool MsgChessRoom::has_game_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgChessRoom::set_has_game_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgChessRoom::clear_has_game_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgChessRoom::clear_game_count() {
  game_count_ = 0u;
  clear_has_game_count();
}
inline ::google::protobuf::uint32 MsgChessRoom::game_count() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.game_count)
  return game_count_;
}
inline void MsgChessRoom::set_game_count(::google::protobuf::uint32 value) {
  set_has_game_count();
  game_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.game_count)
}

// optional .MsgCreatePrivateRoom private_room = 6;
inline bool MsgChessRoom::has_private_room() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgChessRoom::set_has_private_room() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgChessRoom::clear_has_private_room() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgChessRoom::clear_private_room() {
  if (private_room_ != NULL) private_room_->::MsgCreatePrivateRoom::Clear();
  clear_has_private_room();
}
inline const ::MsgCreatePrivateRoom& MsgChessRoom::private_room() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.private_room)
  return private_room_ != NULL ? *private_room_ : *default_instance_->private_room_;
}
inline ::MsgCreatePrivateRoom* MsgChessRoom::mutable_private_room() {
  set_has_private_room();
  if (private_room_ == NULL) private_room_ = new ::MsgCreatePrivateRoom;
  // @@protoc_insertion_point(field_mutable:MsgChessRoom.private_room)
  return private_room_;
}
inline ::MsgCreatePrivateRoom* MsgChessRoom::release_private_room() {
  clear_has_private_room();
  ::MsgCreatePrivateRoom* temp = private_room_;
  private_room_ = NULL;
  return temp;
}
inline void MsgChessRoom::set_allocated_private_room(::MsgCreatePrivateRoom* private_room) {
  delete private_room_;
  private_room_ = private_room;
  if (private_room) {
    set_has_private_room();
  } else {
    clear_has_private_room();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessRoom.private_room)
}

// optional .MsgRoleHostCount role_host = 7;
inline bool MsgChessRoom::has_role_host() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgChessRoom::set_has_role_host() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgChessRoom::clear_has_role_host() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgChessRoom::clear_role_host() {
  if (role_host_ != NULL) role_host_->::MsgRoleHostCount::Clear();
  clear_has_role_host();
}
inline const ::MsgRoleHostCount& MsgChessRoom::role_host() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.role_host)
  return role_host_ != NULL ? *role_host_ : *default_instance_->role_host_;
}
inline ::MsgRoleHostCount* MsgChessRoom::mutable_role_host() {
  set_has_role_host();
  if (role_host_ == NULL) role_host_ = new ::MsgRoleHostCount;
  // @@protoc_insertion_point(field_mutable:MsgChessRoom.role_host)
  return role_host_;
}
inline ::MsgRoleHostCount* MsgChessRoom::release_role_host() {
  clear_has_role_host();
  ::MsgRoleHostCount* temp = role_host_;
  role_host_ = NULL;
  return temp;
}
inline void MsgChessRoom::set_allocated_role_host(::MsgRoleHostCount* role_host) {
  delete role_host_;
  role_host_ = role_host;
  if (role_host) {
    set_has_role_host();
  } else {
    clear_has_role_host();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessRoom.role_host)
}

// optional .MsgRoleStateCount role_state = 8;
inline bool MsgChessRoom::has_role_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgChessRoom::set_has_role_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgChessRoom::clear_has_role_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgChessRoom::clear_role_state() {
  if (role_state_ != NULL) role_state_->::MsgRoleStateCount::Clear();
  clear_has_role_state();
}
inline const ::MsgRoleStateCount& MsgChessRoom::role_state() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.role_state)
  return role_state_ != NULL ? *role_state_ : *default_instance_->role_state_;
}
inline ::MsgRoleStateCount* MsgChessRoom::mutable_role_state() {
  set_has_role_state();
  if (role_state_ == NULL) role_state_ = new ::MsgRoleStateCount;
  // @@protoc_insertion_point(field_mutable:MsgChessRoom.role_state)
  return role_state_;
}
inline ::MsgRoleStateCount* MsgChessRoom::release_role_state() {
  clear_has_role_state();
  ::MsgRoleStateCount* temp = role_state_;
  role_state_ = NULL;
  return temp;
}
inline void MsgChessRoom::set_allocated_role_state(::MsgRoleStateCount* role_state) {
  delete role_state_;
  role_state_ = role_state;
  if (role_state) {
    set_has_role_state();
  } else {
    clear_has_role_state();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessRoom.role_state)
}

// optional bool relieve = 9;
inline bool MsgChessRoom::has_relieve() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MsgChessRoom::set_has_relieve() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MsgChessRoom::clear_has_relieve() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MsgChessRoom::clear_relieve() {
  relieve_ = false;
  clear_has_relieve();
}
inline bool MsgChessRoom::relieve() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.relieve)
  return relieve_;
}
inline void MsgChessRoom::set_relieve(bool value) {
  set_has_relieve();
  relieve_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.relieve)
}

// optional uint32 room_pay_type = 10;
inline bool MsgChessRoom::has_room_pay_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgChessRoom::set_has_room_pay_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgChessRoom::clear_has_room_pay_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgChessRoom::clear_room_pay_type() {
  room_pay_type_ = 0u;
  clear_has_room_pay_type();
}
inline ::google::protobuf::uint32 MsgChessRoom::room_pay_type() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.room_pay_type)
  return room_pay_type_;
}
inline void MsgChessRoom::set_room_pay_type(::google::protobuf::uint32 value) {
  set_has_room_pay_type();
  room_pay_type_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.room_pay_type)
}

// optional uint64 action_id = 11;
inline bool MsgChessRoom::has_action_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MsgChessRoom::set_has_action_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MsgChessRoom::clear_has_action_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MsgChessRoom::clear_action_id() {
  action_id_ = GOOGLE_ULONGLONG(0);
  clear_has_action_id();
}
inline ::google::protobuf::uint64 MsgChessRoom::action_id() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.action_id)
  return action_id_;
}
inline void MsgChessRoom::set_action_id(::google::protobuf::uint64 value) {
  set_has_action_id();
  action_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.action_id)
}

// optional uint32 wiki = 12;
inline bool MsgChessRoom::has_wiki() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MsgChessRoom::set_has_wiki() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MsgChessRoom::clear_has_wiki() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MsgChessRoom::clear_wiki() {
  wiki_ = 0u;
  clear_has_wiki();
}
inline ::google::protobuf::uint32 MsgChessRoom::wiki() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.wiki)
  return wiki_;
}
inline void MsgChessRoom::set_wiki(::google::protobuf::uint32 value) {
  set_has_wiki();
  wiki_ = value;
  // @@protoc_insertion_point(field_set:MsgChessRoom.wiki)
}

// optional .MsgChessChessManual last_chess = 13;
inline bool MsgChessRoom::has_last_chess() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MsgChessRoom::set_has_last_chess() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MsgChessRoom::clear_has_last_chess() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MsgChessRoom::clear_last_chess() {
  if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
  clear_has_last_chess();
}
inline const ::MsgChessChessManual& MsgChessRoom::last_chess() const {
  // @@protoc_insertion_point(field_get:MsgChessRoom.last_chess)
  return last_chess_ != NULL ? *last_chess_ : *default_instance_->last_chess_;
}
inline ::MsgChessChessManual* MsgChessRoom::mutable_last_chess() {
  set_has_last_chess();
  if (last_chess_ == NULL) last_chess_ = new ::MsgChessChessManual;
  // @@protoc_insertion_point(field_mutable:MsgChessRoom.last_chess)
  return last_chess_;
}
inline ::MsgChessChessManual* MsgChessRoom::release_last_chess() {
  clear_has_last_chess();
  ::MsgChessChessManual* temp = last_chess_;
  last_chess_ = NULL;
  return temp;
}
inline void MsgChessRoom::set_allocated_last_chess(::MsgChessChessManual* last_chess) {
  delete last_chess_;
  last_chess_ = last_chess;
  if (last_chess) {
    set_has_last_chess();
  } else {
    clear_has_last_chess();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessRoom.last_chess)
}

// -------------------------------------------------------------------

// MsgChessGameOverInfo

// optional uint32 win_count = 1;
inline bool MsgChessGameOverInfo::has_win_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessGameOverInfo::set_has_win_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessGameOverInfo::clear_has_win_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessGameOverInfo::clear_win_count() {
  win_count_ = 0u;
  clear_has_win_count();
}
inline ::google::protobuf::uint32 MsgChessGameOverInfo::win_count() const {
  // @@protoc_insertion_point(field_get:MsgChessGameOverInfo.win_count)
  return win_count_;
}
inline void MsgChessGameOverInfo::set_win_count(::google::protobuf::uint32 value) {
  set_has_win_count();
  win_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessGameOverInfo.win_count)
}

// optional uint32 lose_count = 2;
inline bool MsgChessGameOverInfo::has_lose_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessGameOverInfo::set_has_lose_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessGameOverInfo::clear_has_lose_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessGameOverInfo::clear_lose_count() {
  lose_count_ = 0u;
  clear_has_lose_count();
}
inline ::google::protobuf::uint32 MsgChessGameOverInfo::lose_count() const {
  // @@protoc_insertion_point(field_get:MsgChessGameOverInfo.lose_count)
  return lose_count_;
}
inline void MsgChessGameOverInfo::set_lose_count(::google::protobuf::uint32 value) {
  set_has_lose_count();
  lose_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessGameOverInfo.lose_count)
}

// optional uint32 peace_count = 3;
inline bool MsgChessGameOverInfo::has_peace_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgChessGameOverInfo::set_has_peace_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgChessGameOverInfo::clear_has_peace_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgChessGameOverInfo::clear_peace_count() {
  peace_count_ = 0u;
  clear_has_peace_count();
}
inline ::google::protobuf::uint32 MsgChessGameOverInfo::peace_count() const {
  // @@protoc_insertion_point(field_get:MsgChessGameOverInfo.peace_count)
  return peace_count_;
}
inline void MsgChessGameOverInfo::set_peace_count(::google::protobuf::uint32 value) {
  set_has_peace_count();
  peace_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessGameOverInfo.peace_count)
}

// -------------------------------------------------------------------

// MsgChessShowDown

// optional .TChessState room_state = 1;
inline bool MsgChessShowDown::has_room_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessShowDown::set_has_room_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessShowDown::clear_has_room_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessShowDown::clear_room_state() {
  room_state_ = 0;
  clear_has_room_state();
}
inline ::TChessState MsgChessShowDown::room_state() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.room_state)
  return static_cast< ::TChessState >(room_state_);
}
inline void MsgChessShowDown::set_room_state(::TChessState value) {
  assert(::TChessState_IsValid(value));
  set_has_room_state();
  room_state_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.room_state)
}

// optional uint32 state_time = 2;
inline bool MsgChessShowDown::has_state_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessShowDown::set_has_state_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessShowDown::clear_has_state_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessShowDown::clear_state_time() {
  state_time_ = 0u;
  clear_has_state_time();
}
inline ::google::protobuf::uint32 MsgChessShowDown::state_time() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.state_time)
  return state_time_;
}
inline void MsgChessShowDown::set_state_time(::google::protobuf::uint32 value) {
  set_has_state_time();
  state_time_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.state_time)
}

// repeated .MsgChessPlayer player_list = 3;
inline int MsgChessShowDown::player_list_size() const {
  return player_list_.size();
}
inline void MsgChessShowDown::clear_player_list() {
  player_list_.Clear();
}
inline const ::MsgChessPlayer& MsgChessShowDown::player_list(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.player_list)
  return player_list_.Get(index);
}
inline ::MsgChessPlayer* MsgChessShowDown::mutable_player_list(int index) {
  // @@protoc_insertion_point(field_mutable:MsgChessShowDown.player_list)
  return player_list_.Mutable(index);
}
inline ::MsgChessPlayer* MsgChessShowDown::add_player_list() {
  // @@protoc_insertion_point(field_add:MsgChessShowDown.player_list)
  return player_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >&
MsgChessShowDown::player_list() const {
  // @@protoc_insertion_point(field_list:MsgChessShowDown.player_list)
  return player_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgChessPlayer >*
MsgChessShowDown::mutable_player_list() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessShowDown.player_list)
  return &player_list_;
}

// optional uint64 room_id = 4;
inline bool MsgChessShowDown::has_room_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgChessShowDown::set_has_room_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgChessShowDown::clear_has_room_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgChessShowDown::clear_room_id() {
  room_id_ = GOOGLE_ULONGLONG(0);
  clear_has_room_id();
}
inline ::google::protobuf::uint64 MsgChessShowDown::room_id() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.room_id)
  return room_id_;
}
inline void MsgChessShowDown::set_room_id(::google::protobuf::uint64 value) {
  set_has_room_id();
  room_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.room_id)
}

// optional uint64 win_id = 5;
inline bool MsgChessShowDown::has_win_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgChessShowDown::set_has_win_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgChessShowDown::clear_has_win_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgChessShowDown::clear_win_id() {
  win_id_ = GOOGLE_ULONGLONG(0);
  clear_has_win_id();
}
inline ::google::protobuf::uint64 MsgChessShowDown::win_id() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.win_id)
  return win_id_;
}
inline void MsgChessShowDown::set_win_id(::google::protobuf::uint64 value) {
  set_has_win_id();
  win_id_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.win_id)
}

// optional uint32 game_count = 6;
inline bool MsgChessShowDown::has_game_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgChessShowDown::set_has_game_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgChessShowDown::clear_has_game_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgChessShowDown::clear_game_count() {
  game_count_ = 0u;
  clear_has_game_count();
}
inline ::google::protobuf::uint32 MsgChessShowDown::game_count() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.game_count)
  return game_count_;
}
inline void MsgChessShowDown::set_game_count(::google::protobuf::uint32 value) {
  set_has_game_count();
  game_count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.game_count)
}

// optional uint32 time = 7;
inline bool MsgChessShowDown::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgChessShowDown::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgChessShowDown::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgChessShowDown::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 MsgChessShowDown::time() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.time)
  return time_;
}
inline void MsgChessShowDown::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.time)
}

// optional bool game_over = 8;
inline bool MsgChessShowDown::has_game_over() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MsgChessShowDown::set_has_game_over() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MsgChessShowDown::clear_has_game_over() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MsgChessShowDown::clear_game_over() {
  game_over_ = false;
  clear_has_game_over();
}
inline bool MsgChessShowDown::game_over() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.game_over)
  return game_over_;
}
inline void MsgChessShowDown::set_game_over(bool value) {
  set_has_game_over();
  game_over_ = value;
  // @@protoc_insertion_point(field_set:MsgChessShowDown.game_over)
}

// repeated .MsgChessIntegralCount integral_list = 9;
inline int MsgChessShowDown::integral_list_size() const {
  return integral_list_.size();
}
inline void MsgChessShowDown::clear_integral_list() {
  integral_list_.Clear();
}
inline const ::MsgChessIntegralCount& MsgChessShowDown::integral_list(int index) const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.integral_list)
  return integral_list_.Get(index);
}
inline ::MsgChessIntegralCount* MsgChessShowDown::mutable_integral_list(int index) {
  // @@protoc_insertion_point(field_mutable:MsgChessShowDown.integral_list)
  return integral_list_.Mutable(index);
}
inline ::MsgChessIntegralCount* MsgChessShowDown::add_integral_list() {
  // @@protoc_insertion_point(field_add:MsgChessShowDown.integral_list)
  return integral_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MsgChessIntegralCount >&
MsgChessShowDown::integral_list() const {
  // @@protoc_insertion_point(field_list:MsgChessShowDown.integral_list)
  return integral_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MsgChessIntegralCount >*
MsgChessShowDown::mutable_integral_list() {
  // @@protoc_insertion_point(field_mutable_list:MsgChessShowDown.integral_list)
  return &integral_list_;
}

// optional .MsgChessChessManual last_chess = 10;
inline bool MsgChessShowDown::has_last_chess() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MsgChessShowDown::set_has_last_chess() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MsgChessShowDown::clear_has_last_chess() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MsgChessShowDown::clear_last_chess() {
  if (last_chess_ != NULL) last_chess_->::MsgChessChessManual::Clear();
  clear_has_last_chess();
}
inline const ::MsgChessChessManual& MsgChessShowDown::last_chess() const {
  // @@protoc_insertion_point(field_get:MsgChessShowDown.last_chess)
  return last_chess_ != NULL ? *last_chess_ : *default_instance_->last_chess_;
}
inline ::MsgChessChessManual* MsgChessShowDown::mutable_last_chess() {
  set_has_last_chess();
  if (last_chess_ == NULL) last_chess_ = new ::MsgChessChessManual;
  // @@protoc_insertion_point(field_mutable:MsgChessShowDown.last_chess)
  return last_chess_;
}
inline ::MsgChessChessManual* MsgChessShowDown::release_last_chess() {
  clear_has_last_chess();
  ::MsgChessChessManual* temp = last_chess_;
  last_chess_ = NULL;
  return temp;
}
inline void MsgChessShowDown::set_allocated_last_chess(::MsgChessChessManual* last_chess) {
  delete last_chess_;
  last_chess_ = last_chess;
  if (last_chess) {
    set_has_last_chess();
  } else {
    clear_has_last_chess();
  }
  // @@protoc_insertion_point(field_set_allocated:MsgChessShowDown.last_chess)
}

// -------------------------------------------------------------------

// MsgChessIntegralCount

// optional uint64 roleid = 1;
inline bool MsgChessIntegralCount::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgChessIntegralCount::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgChessIntegralCount::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgChessIntegralCount::clear_roleid() {
  roleid_ = GOOGLE_ULONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::uint64 MsgChessIntegralCount::roleid() const {
  // @@protoc_insertion_point(field_get:MsgChessIntegralCount.roleid)
  return roleid_;
}
inline void MsgChessIntegralCount::set_roleid(::google::protobuf::uint64 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:MsgChessIntegralCount.roleid)
}

// optional uint32 count = 2;
inline bool MsgChessIntegralCount::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgChessIntegralCount::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgChessIntegralCount::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgChessIntegralCount::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 MsgChessIntegralCount::count() const {
  // @@protoc_insertion_point(field_get:MsgChessIntegralCount.count)
  return count_;
}
inline void MsgChessIntegralCount::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:MsgChessIntegralCount.count)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::TChessState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessState>() {
  return ::TChessState_descriptor();
}
template <> struct is_proto_enum< ::TChessPlayerState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessPlayerState>() {
  return ::TChessPlayerState_descriptor();
}
template <> struct is_proto_enum< ::TChessPlayerWik> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessPlayerWik>() {
  return ::TChessPlayerWik_descriptor();
}
template <> struct is_proto_enum< ::TChessType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessType>() {
  return ::TChessType_descriptor();
}
template <> struct is_proto_enum< ::TChessColor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessColor>() {
  return ::TChessColor_descriptor();
}
template <> struct is_proto_enum< ::TChessShow> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessShow>() {
  return ::TChessShow_descriptor();
}
template <> struct is_proto_enum< ::TChessStepState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TChessStepState>() {
  return ::TChessStepState_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_msg_5fchess_2eproto__INCLUDED
